<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>transparentpath.gcsutils.transparentpath API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>transparentpath.gcsutils.transparentpath</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import warnings
import builtins
import os
import json
import sys
import tempfile
from time import time
from copy import copy
from datetime import datetime
from pathlib import Path
from typing import Union, Tuple, Any, Iterator, Optional, Iterable, List, Callable

from .methodtranslator import MultiMethodTranslator
import gcsfs
from fsspec.implementations.local import LocalFileSystem
from inspect import signature
import collections


class TPMultipleExistenceError(Exception):
    &#34;&#34;&#34;Exception raised when a path&#39;s destination already contain more than
    one element.
    &#34;&#34;&#34;

    def __init__(self, path, ls):
        self.path = path
        self.ls = ls
        self.message = (
            f&#34;Error in TransparentPath: Multiple objects exist at path {path}.\nHere is the output of ls in the &#34;
            f&#34;parent directory:\n {self.ls}&#34;
        )
        super().__init__(self.message)

    def __str__(self):
        return self.message


class TPCachingWarning(Warning):
    def __init__(self, message: str = &#34;&#34;):
        self.message = message
        super().__init__(self.message)


def errormessage(which) -&gt; str:
    return (
        f&#34;Support for {which} does not seem to be installed for TransparentPath.\n&#34;
        f&#34;You can change that by running &#39;pip install transparentpath[{which}]&#39;.&#34;
    )


def errorfunction(which) -&gt; Callable:
    # noinspection PyUnusedLocal
    def _errorfunction(*args, **kwargs):
        raise ImportError(errormessage(which))

    return _errorfunction


# So I can use it in myisinstance
class TransparentPath:
    def __fspath__(self) -&gt; str:
        &#34;&#34;&#34;Implemented later&#34;&#34;&#34;
        pass


builtins_isinstance = builtins.isinstance


def mysmallisinstance(obj1: Any, obj2) -&gt; bool:
    &#34;&#34;&#34;Will return True when testing whether a TransparentPath is a str (required to use open(TransparentPath()))
    or a TransparentPath, and False in every other cases (even pathlib.Path).&#34;&#34;&#34;

    if type(obj1) == TransparentPath:
        if obj2 == TransparentPath or obj2 == str:
            return True
        else:
            return False

    if obj2 == TransparentPath:
        if type(obj1) == TransparentPath:
            return True
        else:
            return False

    return builtins_isinstance(obj1, obj2)


def myisinstance(obj1: Any, obj2) -&gt; bool:
    &#34;&#34;&#34;Will return True when testing whether a TransparentPath is a str (required to use open(TransparentPath()))
    and False when testing whether a pathlib.Path is a TransparentPath.&#34;&#34;&#34;

    if not (builtins_isinstance(obj2, list) or builtins_isinstance(obj2, set) or builtins_isinstance(obj2, tuple)):
        return mysmallisinstance(obj1, obj2)
    else:
        is_instance = False
        for _type in obj2:
            is_instance |= mysmallisinstance(obj1, _type)
        return is_instance


setattr(builtins, &#34;isinstance&#34;, myisinstance)


def collapse_ddots(path: Union[Path, TransparentPath, str]) -&gt; TransparentPath:
    &#34;&#34;&#34;Collapses the double-dots (..) in the path

    Parameters
    ----------
    path: Union[Path, TransparentPath, str]
        The path containing double-dots

    Returns
    -------
    TransparentPath
        The collapsed path.

    &#34;&#34;&#34;
    # noinspection PyUnresolvedReferences
    thetype = path.fs_kind if type(path) == TransparentPath else None
    # noinspection PyUnresolvedReferences
    thebucket = path.bucket if type(path) == TransparentPath else None
    # noinspection PyUnresolvedReferences
    notupdatecache = path.notupdatecache if type(path) == TransparentPath else None
    # noinspection PyUnresolvedReferences
    when_checked = path.when_checked if type(path) == TransparentPath else None
    # noinspection PyUnresolvedReferences
    when_updated = path.when_updated if type(path) == TransparentPath else None
    # noinspection PyUnresolvedReferences
    update_expire = path.update_expire if type(path) == TransparentPath else None
    # noinspection PyUnresolvedReferences
    check_expire = path.check_expire if type(path) == TransparentPath else None
    # noinspection PyUnresolvedReferences

    newpath = Path(path) if type(path) == str else path

    if str(newpath) == &#34;..&#34; or str(newpath) == &#34;/..&#34;:
        raise ValueError(&#34;Can not go before root&#34;)

    while &#34;..&#34; in newpath.parts:
        # noinspection PyUnresolvedReferences
        newnewpath = Path(newpath.parts[0])
        for part in newpath.parts[1:]:
            if part == &#34;..&#34;:
                newnewpath = newnewpath.parent
            else:
                newnewpath /= part
        newpath = newnewpath

    if str(newpath) == str(path):
        return path
    return (
        TransparentPath(
            newpath,
            collapse=False,
            nocheck=True,
            fs=thetype,
            bucket=thebucket,
            notupdatecache=notupdatecache,
            when_checked=when_checked,
            when_updated=when_updated,
            update_expire=update_expire,
            check_expire=check_expire,
        )
        if thetype is not None
        else newpath
    )


def treat_remote_prefix(path: Union[Path, TransparentPath, str], bucket: str) -&gt; Tuple[str, str]:
    splitted = str(path).split(TransparentPath.remote_prefix)
    if len(splitted) == 0:
        if bucket is None and TransparentPath.bucket is None:
            raise ValueError(
                &#34;If using a path starting with &#39;gs://&#39;, you must include the bucket name in it unless it&#34;
                &#34;is specified with bucket= or if TransparentPath already has been set to use a specified bucket&#34;
                &#34;with set_global_fs&#34;
            )
        path = str(path).replace(TransparentPath.remote_prefix, &#34;&#34;, 1)

    else:
        bucket_from_path = splitted[1].split(&#34;/&#34;)[0]
        if bucket is not None:
            if bucket != bucket_from_path:
                raise ValueError(
                    f&#34;Bucket name {bucket_from_path} was found in your path name, but it does &#34;
                    f&#34;not match the bucket name you specified with bucket={bucket}&#34;
                )
        else:
            bucket = bucket_from_path

        path = str(path).replace(TransparentPath.remote_prefix, &#34;&#34;, 1)
        if path.startswith(bucket_from_path) or (len(path) &gt; 0 and path[1:].startswith(bucket_from_path)):
            path = path.replace(bucket_from_path, &#34;&#34;, 1)
        if path.startswith(&#34;/&#34;):
            path = path[1:]
    return path, bucket


def get_fs(
    fs_kind: str,
    bucket: Union[str, None] = None,
    token: Optional[Union[str, dict]] = None,
    path: Union[Path, None] = None,
) -&gt; Tuple[Union[gcsfs.GCSFileSystem, LocalFileSystem], str, str]:
    &#34;&#34;&#34;Gets the FileSystem object of either gcs or local (Default)

    If GCS is asked and bucket is specified, will check that it exists and is accessible.

    Parameters
    ----------
    fs_kind: str
        Returns GCSFileSystem if &#39;gcs_*&#39;, LocalFilsSystem if &#39;local&#39;.
    bucket: str
        bucket name for GCS
    token: Optional[Union[str, dict]]
        credentials (default value = None)
    path: Pathlib.Path
        Only relevant if the method was called from TransparentPath.__init__() : will attempts to fetch the bucket
        from the path if bucket is not given

    Returns
    -------
    Tuple[Union[gcsfs.GCSFileSystem, LocalFileSystem], Union[None, str], Union[None, str], Union[None, str]]
        The FileSystem object, the project if on GCS else None, and the bucket if on GCS.
    &#34;&#34;&#34;

    if fs_kind is None:
        fs_kind = &#34;&#34;
    if fs_kind == &#34;&#34; and token is not None:
        fs_kind = &#34;gcs&#34;
    fs_name = None
    if fs_kind == &#34;local&#34;:
        bucket = None

    if path is not None and fs_kind != &#34;local&#34;:
        # Called from TransparentPath.__init__()
        if bucket is not None:
            fs_name = check_bucket(bucket)
        if bucket is None and len(path.parts) &gt; 0:
            bucket = path.parts[0]
            fs_name = check_bucket(bucket)
            if fs_name is None:
                bucket = None
        if bucket is None:
            bucket = TransparentPath.bucket
            fs_name = check_bucket(bucket)

        if fs_name is not None:
            return copy(TransparentPath.fss[fs_name]), fs_name, bucket

    if &#34;gcs&#34; in fs_kind or token is not None:

        # If bucket is specified, get the filesystem that contains it if it already exists. Else, create the filesystem.
        if bucket is not None:
            fs_name = check_bucket(bucket)
            if fs_name is not None:
                fs = copy(TransparentPath.fss[fs_name])
                return fs, fs_name, &#34;&#34;

        fs_name, project, token = extract_fs_name(token)
        if fs_name in TransparentPath.fss:
            pass
        elif token is None:
            fs = gcsfs.GCSFileSystem(project=project, asynchronous=False)
            TransparentPath.buckets_in_project[fs_name] = get_buckets(fs)
            TransparentPath.fss[fs_name] = fs
        else:
            fs = gcsfs.GCSFileSystem(project=project, asynchronous=False, token=token)
            TransparentPath.buckets_in_project[fs_name] = get_buckets(fs)
            TransparentPath.fss[fs_name] = fs

        ret_bucket = False
        if bucket is None and path is not None and len(path.parts) &gt; 0:
            bucket = path.parts[0]
            ret_bucket = True
        if bucket is not None:
            if not bucket.endswith(&#34;/&#34;):
                bucket += &#34;/&#34;
            if bucket not in TransparentPath.buckets_in_project[fs_name]:
                raise NotADirectoryError(f&#34;Bucket {bucket} does not exist in any loaded projects&#34;)

        fs = copy(TransparentPath.fss[fs_name])
        if ret_bucket:
            return fs, fs_name, bucket
        else:
            return fs, fs_name, &#34;&#34;
    else:
        if &#34;local&#34; not in TransparentPath.fss:
            TransparentPath.fss[&#34;local&#34;] = LocalFileSystem()
        return copy(TransparentPath.fss[&#34;local&#34;]), &#34;local&#34;, &#34;&#34;


def get_buckets(fs: gcsfs.GCSFileSystem) -&gt; List[str]:
    &#34;&#34;&#34;Return list of all buckets in the file system.&#34;&#34;&#34;
    if &#34;&#34; not in fs.dircache:
        items = []
        page = fs.call(&#34;GET&#34;, &#34;b/&#34;, project=fs.project, json_out=True)

        assert page[&#34;kind&#34;] == &#34;storage#buckets&#34;
        items.extend(page.get(&#34;items&#34;, []))
        next_page_token = page.get(&#34;nextPageToken&#34;, None)

        while next_page_token is not None:
            page = fs.call(
                &#34;GET&#34;,
                &#34;b/&#34;,
                project=fs.project,
                pageToken=next_page_token,
                json_out=True,
            )

            assert page[&#34;kind&#34;] == &#34;storage#buckets&#34;
            items.extend(page.get(&#34;items&#34;, []))
            next_page_token = page.get(&#34;nextPageToken&#34;, None)
        fs.dircache[&#34;&#34;] = [{&#34;name&#34;: i[&#34;name&#34;] + &#34;/&#34;, &#34;size&#34;: 0, &#34;type&#34;: &#34;directory&#34;} for i in items]
    return [b[&#34;name&#34;] for b in fs.dircache[&#34;&#34;]]


def check_bucket(bucket: Union[str, None]) -&gt; Union[str, None]:
    &#34;&#34;&#34;Check that the bucket exists in an initiated file system and returns the corresponding file system&#39;s name,
    or raises NotADirectoryError.&#34;&#34;&#34;
    if bucket is None:
        return None
    bucket = str(bucket)
    if not bucket.endswith(&#34;/&#34;):
        bucket += &#34;/&#34;
    fs = None
    for proj in TransparentPath.buckets_in_project:
        if bucket in TransparentPath.buckets_in_project[proj]:
            fs = proj
            break
    return fs


def check_kwargs(method: Callable, kwargs: dict):
    &#34;&#34;&#34;Takes as argument a method and some kwargs. Will look in the method signature and return in two separate dict
    the kwargs that are in the signature and those that are not.

    If the method does not return any signature or if it explicitely accepts **kwargs, does not do anything
    &#34;&#34;&#34;
    unexpected_kwargs = []
    s = &#34;&#34;
    try:
        sig = signature(method)
        if &#34;kwargs&#34; in sig.parameters or &#34;kwds&#34; in sig.parameters:
            return
        for arg in kwargs:
            if arg not in sig.parameters:
                unexpected_kwargs.append(f&#34;{arg}={kwargs[arg]}&#34;)

        if len(unexpected_kwargs) &gt; 0:
            s = f&#34;You provided unexpected kwargs for method {method.__name__}:&#34;
            s = &#34;\n  - &#34;.join([s] + unexpected_kwargs)
    except ValueError:
        return

    if s != &#34;&#34;:
        raise ValueError(s)


def get_index_and_date_from_kwargs(**kwargs: dict) -&gt; Tuple[int, bool, dict]:
    index_col = kwargs.get(&#34;index_col&#34;, None)
    parse_dates = kwargs.get(&#34;parse_dates&#34;, None)
    if index_col is not None:
        del kwargs[&#34;index_col&#34;]
    if parse_dates is not None:
        del kwargs[&#34;parse_dates&#34;]
    # noinspection PyTypeChecker
    return index_col, parse_dates, kwargs


def extract_fs_name(token: str = None) -&gt; Tuple[str, str, Union[str, None]]:
    if token is None and &#34;GOOGLE_APPLICATION_CREDENTIALS&#34; not in os.environ:
        fs = gcsfs.GCSFileSystem()
        project = fs.project
        if (
            project is None
            or fs.credentials is None
            or not hasattr(fs.credentials.credentials, &#34;service_account_email&#34;)
            or fs.credentials.credentials.service_account_email is None
        ):
            raise EnvironmentError(
                &#34;If no token is explicitely specified and GOOGLE_APPLICATION_CREDENTIALS environnement variable is not&#34;
                &#34; set, you need to have done gcloud init or to be on GCP already to create a TransparentPath&#34;
            )
        email = fs.credentials.credentials.service_account_email
        return f&#34;gcs_{project}_{email}&#34;, project, None
    elif token is None:
        token = os.getenv(&#34;GOOGLE_APPLICATION_CREDENTIALS&#34;)

    token = token.strip()
    if not TransparentPath(token, fs=&#34;local&#34;, nocheck=True, notupdatecache=True).is_file():
        raise FileNotFoundError(f&#34;Credential file {token} not found&#34;)
    content = json.load(open(token))
    if &#34;project_id&#34; not in content:
        raise ValueError(f&#34;Credential file {token} does not contain project_id key.&#34;)
    if &#34;client_email&#34; not in content:
        raise ValueError(f&#34;Credential file {token} does not contain client_email key.&#34;)

    fs_name = f&#34;gcs_{content[&#39;project_id&#39;]}_{content[&#39;client_email&#39;]}&#34;
    TransparentPath.tokens[fs_name] = token
    return fs_name, content[&#34;project_id&#34;], token


class TransparentPath(os.PathLike):  # noqa : F811
    # noinspection PyUnresolvedReferences
    &#34;&#34;&#34;
    A class that allows one to use a path in a local file system or a Google Cloud Storage (GCS) file system in the
    same way one would use a `pathlib.Path` object. One can use many different GCP projects at once.

    Create a path that points to GCS, and one that does not:
    &gt;&gt;&gt; from transparentpath import Path
    &gt;&gt;&gt; # Or : from transparentpath import TransparentPath
    &gt;&gt;&gt; p = Path(&#34;gs://mybucket/some_path&#34;, token=&#34;some/cred/file.json&#34;)
    &gt;&gt;&gt; p2 = p / &#34;foo&#34;  # Will point to gs://mybucket/some_path/foo
    &gt;&gt;&gt; p3 = Path(&#34;bar&#34;)  # Will point to local path &#34;bar&#34;

    Set all paths to point to GCS by default:
    &gt;&gt;&gt; from transparentpath import Path
    &gt;&gt;&gt; Path.set_global_fs(&#34;gcs&#34;, token=&#34;some/cred/file.json&#34;)
    &gt;&gt;&gt; p = Path(&#34;mybucket&#34;) / &#34;some_path&#34; # Will point to gs://mybucket/some_path
    &gt;&gt;&gt; p2 = p / &#34;foo&#34;  # Will point to gs://mybucket/some_path/foo
    &gt;&gt;&gt; p3 = Path(&#34;bar&#34;, fs=&#34;local&#34;)  # Will point to local path &#34;bar&#34;
    &gt;&gt;&gt; p4 = Path(&#34;other_bucket&#34;)  # Will point to gs://other_bucket (assuming other_bucket is a bucket)
    &gt;&gt;&gt; p5 = Path(&#34;not_a_bucket&#34;)  # Will point to local path &#34;not_a_bucket&#34; (assuming it is indeed, not a bucket)

    Set all paths to point to severral GCS projects by default:
    &gt;&gt;&gt; from transparentpath import Path
    &gt;&gt;&gt; Path.set_global_fs(&#34;gcs&#34;, token=&#34;some/cred/file.json&#34;)
    &gt;&gt;&gt; Path.set_global_fs(&#34;gcs&#34;, token=&#34;some/other/cred/file.json&#34;)
    &gt;&gt;&gt; p = Path(&#34;mybucket&#34;) / &#34;some_path&#34; # Will point to gs://mybucket/some_path
    &gt;&gt;&gt; p2 = p / &#34;foo&#34;  # Will point to gs://mybucket/some_path/foo
    &gt;&gt;&gt; p3 = Path(&#34;bar&#34;, fs=&#34;local&#34;)  # Will point to local path &#34;bar&#34;
    &gt;&gt;&gt; p4 = Path(&#34;other_bucket&#34;)  # Will point to gs://other_bucket (assuming other_bucket is a bucket)
    &gt;&gt;&gt; p5 = Path(&#34;not_a_bucket&#34;)  # Will point to local path &#34;not_a_bucket&#34; (assuming it is indeed, not a bucket)

    Here, *mybucket* and *other_bucket* can be on two different projects, as long as at least one of the
    credential files can access them.

    Set all paths to point to GCS by default, and specify a default bucket:
    &gt;&gt;&gt; from transparentpath import Path
    &gt;&gt;&gt; Path.set_global_fs(&#34;gcs&#34;, bucket=&#34;mybucket&#34;, token=&#34;some/cred/file.json&#34;)
    &gt;&gt;&gt; p = Path(&#34;some_path&#34;)  # Will point to gs://mybucket/some_path/
    &gt;&gt;&gt; p2 = p / &#34;foo&#34;  # Will point to gs://mybucket/some_path/foo
    &gt;&gt;&gt; p3 = Path(&#34;bar&#34;, fs=&#34;local&#34;)  # Will point to local path &#34;bar&#34;
    &gt;&gt;&gt; p4 = Path(&#34;other_bucket&#34;)  # Will point to gs://mybucket/other_bucket
    &gt;&gt;&gt; p5 = Path(&#34;not_a_bucket&#34;)  # Will point to gs://mybucket/not_a_bucket

    The latest option is interesting if you have a code that should be able to run with paths being sometimes remote,
    sometimes local. To do that, you can use the class attribute `nas_dir`. Then when a path is created, if it starts by
    *nas_dir*&#39;s path, *nas_dir*&#39;s path is replaced by the bucket name. This is useful if, for instance, you have a
    backup of a bucket locally at let&#39;s say */my/local/backup*. Then you can do:
    &gt;&gt;&gt; from transparentpath import Path
    &gt;&gt;&gt; Path.nas_dir = &#34;/my/local/backup&#34;
    &gt;&gt;&gt; Path.set_global_fs(&#34;gcs&#34;, bucket=&#34;mybucket&#34;, token=&#34;some/cred/file.json&#34;)
    &gt;&gt;&gt; p = Path(&#34;some_path&#34;)  # Will point to gs://mybucket/some_path/
    &gt;&gt;&gt; p3 = Path(&#34;/my/local/backup&#34;) / &#34;some_path&#34;  # Will ALSO point to gs://mybucket/some_path/

    &gt;&gt;&gt; from transparentpath import Path
    &gt;&gt;&gt; Path.nas_dir = &#34;/my/local/backup&#34;
    &gt;&gt;&gt; # Path.set_global_fs(&#34;gcs&#34;, bucket=&#34;mybucket&#34;, token=&#34;some/cred/file.json&#34;)
    &gt;&gt;&gt; p = Path(&#34;some_path&#34;)  # Will point to /my/local/backup/some_path/
    &gt;&gt;&gt; p3 = Path(&#34;/my/local/backup&#34;) / &#34;some_path&#34;  # Will ALSO point to /my/local/backup/some_path/

    In all the previous examples, the *token* argument can be ommited if the environment variable
    **GOOGLE_APPLICATION_CREDENTIALS** is set and point to a *.json* credential file, or if your code runs on a GCP
    machine (VM, cluster...) with access to GCS.

    No matter whether you are using GCS or your local file system, here is a sample of what TransparentPath can do:
    &gt;&gt;&gt; from transparentpath import Path
    &gt;&gt;&gt; # Path.set_global_fs(&#34;gcs&#34;, bucket=&#34;bucket_name&#34;, project=&#34;project_name&#34;)
    &gt;&gt;&gt; # The following lines will also work with the previous line uncommented
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Reading a csv into a pandas&#39; DataFrame and saving it as a parquet file
    &gt;&gt;&gt; mypath = Path(&#34;foo&#34;) / &#34;bar.csv&#34;
    &gt;&gt;&gt; df = mypath.read(index_col=0, parse_dates=True)
    &gt;&gt;&gt; otherpath = mypath.with_suffix(&#34;.parquet&#34;)
    &gt;&gt;&gt; otherpath.write(df)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Reading and writing a HDF5 file works on GCS and on local:
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; mypath = Path(&#34;foo&#34;) / &#34;bar.hdf5&#34;  # can be .h5 too
    &gt;&gt;&gt; with mypath.read() as ifile:
    &gt;&gt;&gt;     arr = np.array(ifile[&#34;store1&#34;])
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Doing &#39;..&#39; from &#39;foo/bar.hdf5&#39; will return &#39;foo&#39;
    &gt;&gt;&gt; # Then doing &#39;foo&#39; + &#39;babar.hdf5&#39; will return &#39;foo/babar.hdf5&#39; (&#39;+&#39; and &#39;/&#39; are synonymes)
    &gt;&gt;&gt; mypath.cd(&#34;..&#34;)  # Does not return a path but modifies inplace
    &gt;&gt;&gt; with (mypath  + &#34;babar.hdf5&#34;).write(None) as ofile:
    &gt;&gt;&gt;     # Note here that we must explicitely give &#39;None&#39; to the &#39;write&#39; method in order for it
    &gt;&gt;&gt;     # to return the open HDF5 file. We could also give a dict of {arr: &#34;store1&#34;} to directly
    &gt;&gt;&gt;     # write the file.
    &gt;&gt;&gt;     ofile[&#34;store1&#34;] = arr
    &gt;&gt;&gt;
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Reading a text file. Can also use &#39;w&#39;, &#39;a&#39;, etc... also works with binaries.
    &gt;&gt;&gt; mypath = Path(&#34;foo&#34;) / &#34;bar.txt&#34;
    &gt;&gt;&gt; with open(mypath, &#34;r&#34;) as ifile:
    &gt;&gt;&gt;     lines = ifile.readlines()
    &gt;&gt;&gt;
    &gt;&gt;&gt; # open is overriden to understand gs://
    &gt;&gt;&gt; with open(&#34;gs://bucket/file.txt&#34;, &#34;r&#34;) as ifile:
    &gt;&gt;&gt;     _ = ifile.readlines()
    &gt;&gt;&gt;
    &gt;&gt;&gt; mypath.is_file()
    &gt;&gt;&gt; mypath.is_dir()
    &gt;&gt;&gt; mypath.is_file()
    &gt;&gt;&gt; files = mypath.parent.glob(&#34;*.csv&#34;)  # Returns a Iterator[TransparentPath], can be casted to list

    As you can see from the previous example, all methods returning a path from a TransparentPath return a
    TransparentPath.

    TransparentPath supports writing and reading Dask dataframes from and to csv, excel, parquet and HDF5, both locally
    and remotely. You need to have dask-dataframe and dask-distributed installed, which will be the case if you ran `pip
    install transparentpath[dask]`. Writing Dask dataframes does not require any additionnal arguments to be
    passed for the type will be checked before calling the appropriate writting method. Reading however requires you to
    pass the *use_dask* argument to the `transparentpath.gcsutils.transparentpath.TransparentPath.read()` method.
    If the file to read is HDF5, you will also need to specify *set_names*, matching the argument *key* of Dask&#39;s
    `read_hdf()` method.

    Note that if reading a remote HDF5, the file will be downloaded in your local tmp, then read. If not using Dask, the
    file is deleted after being read. But since Dask uses delayed processes, deleting the file might occure before the
    file is actually read, so the file is kept. Up to you to empty your */tmp* directory if it is not done automatically
    by your system.

    All instances of TransparentPath are absolute, even if created with relative paths.

    TransparentPaths are seen as instances of str:
    &gt;&gt;&gt; from transparentpath import Path
    &gt;&gt;&gt; path = Path()
    &gt;&gt;&gt; isinstance(path, str)  # returns True

    This is required to allow
    &gt;&gt;&gt; from transparentpath import Path
    &gt;&gt;&gt; path = Path()
    &gt;&gt;&gt; # noinspection PyTypeChecker
    &gt;&gt;&gt; with open(path, &#34;w/r/a/b...&#34;) as ifile:
    &gt;&gt;&gt; ...
    to work. If you want to check whether path is actually a TransparentPath and nothing else, use
    &gt;&gt;&gt; from transparentpath import Path
    &gt;&gt;&gt; path = Path()
    &gt;&gt;&gt; assert type(path) == Path
    &gt;&gt;&gt; assert issubclass(path.__class__, Path)
    instead.

    Any method or attribute valid in `fsspec.implementations.local.LocalFileSystem`, `gcs.GCSFileSystem`, `pathlib.Path`
    or `str` can be used on a TransparentPath object.

    **Warnings about GCS behaviour**
    if you use GCS:\n
      1. Remember that directories are not a thing on GCS.\n
      2. You do not need the parent directories of a file on GCS to create the file : they will be created if they do
      not exist (that is not true localy however).\n
      3. If you delete a file that was alone in its parent directories, those directories disapear.\n
      4. If a file exists at the same path than a directory, then TransparentPath is not able to know which one is the
      file and which one is the directory, and will raise a
    `transparentpath.gcsutils.transparentpath.TPMultipleExistenceError` upon object creation. This
      check for multiplicity is done at almost every method in case an exterior source created a duplicate of the
      file/directory. This case can&#39;t happen locally. However, it can happen on remote if the cache is not updated
      frequently. Doing this check can significantly increase computation time (if using glob on a directory
      containing a lot of files for example). You can deactivate it either globally (TransparentPath._do_check =
      False and TransparentPath._do_update_cache = False), for a specific path (pass nockeck=True at path
      creation), or for glob and ls by passing fast=True as additional argument.


    TransparentPath on GCS is slow because of the verification for multiple existance and the cache updating.
    However one can tweak those a bit. As mentionned earlier, cache updating and multiple existence check can be
    deactivated for all paths by doing
    &gt;&gt;&gt; from transparentpath import TransparentPath
    &gt;&gt;&gt; TransparentPath._do_update_cache = False
    &gt;&gt;&gt; TransparentPath._do_check = False

    They can also be deactivated for one path only by doing
    &gt;&gt;&gt; p = TransparentPath(&#34;somepath&#34;, nocheck=True, notupdatecache=True)

    It is also possible to specify when to do those check : at path creation, path usage (read, write, exists...) or
    both. Here to it can be set on all paths or only some :
    &gt;&gt;&gt; TransparentPath._when_checked = {&#34;created&#34;: True, &#34;used&#34;: False}  # Default value
    &gt;&gt;&gt; TransparentPath._when_updated = {&#34;created&#34;: True, &#34;used&#34;: False}  # Default value
    &gt;&gt;&gt; p = TransparentPath(
    &gt;&gt;&gt;   &#34;somepath&#34;, when_checked={&#34;created&#34;: False, &#34;used&#34;: False}, notupdatecache={&#34;created&#34;: False, &#34;used&#34;: False}
    &gt;&gt;&gt; )

    There is also an expiration time in seconds for check and update : the operation is not done if it was done not a
    long time ago. Those expiration times are of 1 second by default and can be changed through :
    &gt;&gt;&gt; TransparentPath._check_expire = 10
    &gt;&gt;&gt; TransparentPath._update_expire = 10
    &gt;&gt;&gt; p = TransparentPath(&#34;somepath&#34;, check_expire=0, update_expire=0)
    ```

    `transparentpath.gcsutils.transparentpath.TransparentPath.glob()` and
    `transparentpath.gcsutils.transparentpath.TransparentPath.ls()` have their own way to be accelerated :
    &gt;&gt;&gt; p.glob(&#34;/*&#34;, fast=True)
    &gt;&gt;&gt; p.ls(&#34;&#34;, fast=True)
    Basically, *fast=True* means &#34;do not check and do not update the cache&#34; for all the items found by the method.

    Builtin `open` is overloaded by TransparentPath to support giving a TransparentPath to it. If a method in a package
    you did not create uses `open` in a *with* statement, everything should work out of the box with a TransparentPath.

    However, if it uses the **output** of `open`, you will have to create a class to
    override this method and anything using its ouput. Indeed, `open` returns a file descriptor, not an IO, and I did
    not find a way to access file descriptors on gcs. For example, in the FileLock package, the `acquire` method calls
    the `_acquire` method which calls `os.open`, so I had to do that:

    &gt;&gt;&gt; from filelock import FileLock
    &gt;&gt;&gt; from transparentpath import Path
    &gt;&gt;&gt;
    &gt;&gt;&gt; class MyFileLock(FileLock):
    &gt;&gt;&gt;     def _acquire(self):
    &gt;&gt;&gt;         tmp_lock_file = self._lock_file
    &gt;&gt;&gt;         if not type(tmp_lock_file) == Path:
    &gt;&gt;&gt;             tmp_lock_file = Path(tmp_lock_file)
    &gt;&gt;&gt;         try:
    &gt;&gt;&gt;             fd = tmp_lock_file.open(&#34;x&#34;)
    &gt;&gt;&gt;         except (IOError, OSError, FileExistsError):
    &gt;&gt;&gt;             pass
    &gt;&gt;&gt;         else:
    &gt;&gt;&gt;             self._lock_file_fd = fd
    &gt;&gt;&gt;         return None

    The original method was:
    &gt;&gt;&gt;
    &gt;&gt;&gt; import os
    &gt;&gt;&gt; ...
    &gt;&gt;&gt; def _acquire(self):
    &gt;&gt;&gt;     open_mode = os.O_WRONLY | os.O_CREAT | os.O_EXCL | os.O_TRUNC
    &gt;&gt;&gt;     try:
    &gt;&gt;&gt;         fd = os.open(self._lock_file, open_mode)
    &gt;&gt;&gt;     except (IOError, OSError):
    &gt;&gt;&gt;         pass
    &gt;&gt;&gt;     else:
    &gt;&gt;&gt;         self._lock_file_fd = fd
    &gt;&gt;&gt;     return None
    &gt;&gt;&gt; ...

    I tried to implement a working version of any method valid in pathlib.Path or in file systems, but futur changes
    in any of those will not be taken into account quickly. You can report missing supports by opening an issue.
    &#34;&#34;&#34;

    @classmethod
    def reinit(cls):
        &#34;&#34;&#34;Reinit all class attributes to their default values&#34;&#34;&#34;
        cls.remote_prefix = &#34;gs://&#34;
        cls.fss = {}
        cls.buckets_in_project = {}
        cls.fs_kind = None
        cls.bucket = None
        cls.nas_dir = None
        cls.unset = True
        cls.cwd = os.getcwd()
        cls.tokens = {}
        cls._do_update_cache = True
        cls._do_check = True
        cls._check_expire = 1
        cls._update_expire = 1
        cls._when_checked = {&#34;used&#34;: False, &#34;created&#34;: True}
        cls._when_updated = {&#34;used&#34;: False, &#34;created&#34;: True}
        cls.LOCAL_SEP = os.path.sep
        cls.cached_data_dict = collections.OrderedDict()
        cls.used_memory = 0
        cls.caching = &#34;None&#34;
        cls.caching_max_memory = 100

    @classmethod
    def show_state(cls):
        &#34;&#34;&#34;Prints the state of the TransparentPath class&#34;&#34;&#34;
        print(&#34;remote_prefix: &#34;, cls.remote_prefix)
        print(&#34;fss: &#34;, cls.fss)
        print(&#34;buckets_in_project: &#34;, cls.buckets_in_project)
        print(&#34;fs_kind: &#34;, cls.fs_kind)
        print(&#34;bucket: &#34;, cls.bucket)
        print(&#34;nas_dir: &#34;, cls.nas_dir)
        print(&#34;unset: &#34;, cls.unset)
        print(&#34;cwd: &#34;, cls.cwd)
        print(&#34;tokens: &#34;, cls.tokens)
        print(&#34;_do_update_cache: &#34;, cls._do_update_cache)
        print(&#34;_do_check: &#34;, cls._do_check)
        print(&#34;_check_expire: &#34;, cls._check_expire)
        print(&#34;_update_expire: &#34;, cls._update_expire)
        print(&#34;_when_updated: &#34;, cls._when_updated)
        print(&#34;LOCAL_SEP: &#34;, cls.LOCAL_SEP)
        print(&#34;cached_data_dict: &#34;, cls.cached_data_dict)
        print(&#34;used_memory: &#34;, cls.used_memory)
        print(&#34;caching: &#34;, cls.caching)
        print(&#34;caching_max_memory: &#34;, cls.caching_max_memory)

    @classmethod
    def get_state(cls) -&gt; dict:
        &#34;&#34;&#34;Returns the state of the TransparentPath class in a dictionnary&#34;&#34;&#34;
        state = {
            &#34;remote_prefix&#34;: cls.remote_prefix,
            &#34;fss&#34;: cls.fss,
            &#34;buckets_in_project&#34;: cls.buckets_in_project,
            &#34;fs_kind&#34;: cls.fs_kind,
            &#34;bucket&#34;: cls.bucket,
            &#34;nas_dir&#34;: cls.nas_dir,
            &#34;unset&#34;: cls.unset,
            &#34;cwd&#34;: cls.cwd,
            &#34;tokens&#34;: cls.tokens,
            &#34;_do_update_cache&#34;: cls._do_update_cache,
            &#34;_do_check&#34;: cls._do_check,
            &#34;_check_expire&#34;: cls._check_expire,
            &#34;_update_expire&#34;: cls._update_expire,
            &#34;_when_checked&#34;: cls._when_checked,
            &#34;_when_updated&#34;: cls._when_updated,
            &#34;LOCAL_SEP&#34;: cls.LOCAL_SEP,
            &#34;cached_data_dict: &#34;: cls.cached_data_dict,
            &#34;used_memory: &#34;: cls.used_memory,
            &#34;caching: &#34;: cls.caching,
            &#34;caching_max_memory: &#34;: cls.caching_max_memory,
        }
        return state

    remote_prefix = &#34;gs://&#34;
    &#34;&#34;&#34;remote prefix of the known possible remote file system. For now, only GCS is supported, so default is gs://&#34;&#34;&#34;
    fss = {}
    &#34;&#34;&#34;Declared filesystems. Keys are &#39;local&#39; or &#39;gcs_cred_mail&#39; and values are
     `fsspec.implementations.local.LocalFileSystem` or `gcsfs.GCSFileSystem` objects&#34;&#34;&#34;
    buckets_in_project = {}
    &#34;&#34;&#34;Known buckets. Keys are &#39;gcs_cred_mail&#39; and values are bucket names (str)&#34;&#34;&#34;
    fs_kind = None
    &#34;&#34;&#34;Default fs kind (&#39;local&#39; or &#39;gcs&#39;)&#34;&#34;&#34;
    bucket = None
    &#34;&#34;&#34;Default bucket&#34;&#34;&#34;
    nas_dir = None
    &#34;&#34;&#34;If found in a remote path, is replaced by the bucket&#34;&#34;&#34;
    unset = True
    &#34;&#34;&#34;False once `transparentpath.gcsutils.transparentpath.TransparentPath.set_global_fs` is called&#34;&#34;&#34;
    cwd = os.getcwd()
    &#34;&#34;&#34;currend working directory&#34;&#34;&#34;
    tokens = {}
    &#34;&#34;&#34;Known credentials. Keys are &#39;gcs_cred_mail&#39; and values are credential files paths (str)&#34;&#34;&#34;
    _do_update_cache = True
    &#34;&#34;&#34;If True, will update the cache according to 
    `transparentpath.gcsutils.transparentpath.TransparentPath._when_checked`&#34;&#34;&#34;
    _do_check = True
    &#34;&#34;&#34;If True, will check for duplicate objects according to 
    `transparentpath.gcsutils.transparentpath.TransparentPath._when_updated`&#34;&#34;&#34;
    _update_expire = 1
    &#34;&#34;&#34;Seconds before cache update expires. 0 means never.&#34;&#34;&#34;
    _check_expire = 1
    &#34;&#34;&#34;Seconds before a check for duplicate objects expires. 0 means never.&#34;&#34;&#34;
    _when_updated = {&#34;used&#34;: False, &#34;created&#34;: True}
    &#34;&#34;&#34;When to update the cache: at path creation and/or at path use.&#34;&#34;&#34;
    _when_checked = {&#34;used&#34;: False, &#34;created&#34;: True}
    &#34;&#34;&#34;When to check for duplicate objects: at path creation and/or at path use.&#34;&#34;&#34;
    LOCAL_SEP = os.path.sep
    &#34;&#34;&#34;Path separator, depends on the OS&#34;&#34;&#34;
    caching: str = &#34;None&#34;
    &#34;&#34;&#34;Caching, meaning file content read from a transparentpath will be saved in tmp for quicker access later in the
    code. Deactivated by default&#34;&#34;&#34;
    caching_max_memory = 100
    &#34;&#34;&#34;Max size allowed in cache (in MB)&#34;&#34;&#34;
    used_memory = 0
    &#34;&#34;&#34;Current cache size (in MB)&#34;&#34;&#34;
    cached_data_dict = collections.OrderedDict()
    &#34;&#34;&#34;caching memory as MB by saved object&#34;&#34;&#34;
    _attributes = [
        &#34;bucket&#34;,
        &#34;fs_kind&#34;,
        &#34;fs&#34;,
        &#34;nas_dir&#34;,
        &#34;path&#34;,
        &#34;sep&#34;,
        &#34;nocheck&#34;,
        &#34;notupdatecache&#34;,
        &#34;last_check&#34;,
        &#34;last_update&#34;,
        &#34;update_expire&#34;,
        &#34;check_expire&#34;,
        &#34;when_checked&#34;,
        &#34;when_updated&#34;,
    ]
    &#34;&#34;&#34;List of class instance attribute names&#34;&#34;&#34;

    method_without_self_path = [
        &#34;end_transaction&#34;,
        &#34;get_mapper&#34;,
        &#34;read_block&#34;,
        &#34;start_transaction&#34;,
        &#34;connect&#34;,
        &#34;load_tokens&#34;,
    ]
    &#34;&#34;&#34;Methods that do not use `transparentpath.gcsutils.transparentpath.TransparentPath.path`&#34;&#34;&#34;

    method_path_concat = []
    &#34;&#34;&#34;Methods present here are assumed that their first argument must be concatenated with
    `transparentpath.gcsutils.transparentpath.TransparentPath.path`&#34;&#34;&#34;

    translations = {
        &#34;mkdir&#34;: MultiMethodTranslator(
            &#34;mkdir&#34;,
            [&#34;local&#34;, &#34;gcs&#34;],
            [&#34;mkdir&#34;, &#34;self._do_nothing&#34;],
            [{&#34;parents&#34;: &#34;create_parents&#34;}, {&#34;parents&#34;: &#34;&#34;}],
        ),
    }
    &#34;&#34;&#34;To translate method args and kwargs between `fsspec.implementations.local.LocalFileSystem` 
    and `gcsfs.GCSFileSystem`&#34;&#34;&#34;

    @classmethod
    def set_global_fs(
        cls,
        fs: str,
        bucket: Union[str, None] = None,
        nas_dir: Optional[Union[TransparentPath, Path, str]] = None,
        token: Optional[Union[dict, str]] = None,
    ) -&gt; None:
        &#34;&#34;&#34;To call before creating any instance to set the file system.

        If not called, default file system is local. If the first parameter is &#39;local&#39;, the file system is local. If
        the first parameter is &#39;gcs&#39;, file system is GCS.

        Parameters
        ----------
        fs: str
            &#39;gcs&#39; will use GCSFileSystem, &#39;local&#39; will use LocalFileSystem
        bucket: str
            The bucket name, only valid if using gcs (Default value =  None)
        nas_dir: Union[TransparentPath, Path, str]
            If specified, TransparentPath will delete any occurence of &#39;nas_dir&#39; at the beginning of created paths if fs
            is gcs (Default value = None).
        token: Optional[Union[dict, str]]
            credentials (default value = None). If not specified, will use envvar GOOGLE_APPLICATION_CREDENTIALS. If not
            specified either, will try to log with default account, which will work is using a machine on GCP
            (VM, cluster...)

        Returns
        -------
        None
        &#34;&#34;&#34;
        if &#34;gcs&#34; not in fs and fs != &#34;local&#34;:
            raise ValueError(f&#34;Unknown value {fs} for parameter &#39;fs&#39;&#34;)

        cls.fs_kind = fs
        cls.bucket = bucket

        TransparentPath._set_nas_dir(cls, nas_dir)
        get_fs(cls.fs_kind, cls.bucket, token)
        TransparentPath.unset = False

    def __init__(
        self,
        path: Union[Path, TransparentPath, str] = &#34;.&#34;,
        collapse: bool = True,
        fs: Optional[str] = &#34;&#34;,
        bucket: Optional[str] = None,
        token: Optional[Union[dict, str]] = None,
        nocheck: Optional[bool] = None,
        notupdatecache: Optional[bool] = None,
        update_expire: Optional[int] = None,
        check_expire: Optional[int] = None,
        when_checked: Optional[dict] = None,
        when_updated: Optional[dict] = None,
        enable_caching: bool = False,
        **kwargs,
    ):
        &#34;&#34;&#34;Creator of the TranparentPath object

        Parameters
        ----------
        path: Union[pathlib.Path, TransparentPath, str]
            The path of the object (Default value = &#39;.&#39;)
        collapse: bool
            If True, will collapse any double dots (&#39;..&#39;) in path. (Default value = True)
        fs: Optional[str]
            The file system to use, &#39;local&#39; or &#39;gcs&#39;. If None, uses the default one set by
            `transparentpath.gcsutils.transparentpath.TransparentPath.set_global_fs` if any, or &#39;local&#39; (Default = None)
        bucket: Optional[str]
            The bucket name if using GCS and if path is not &#39;gs://bucket/...&#39;
        token: Optional[Union[dict, str]]
            The path to google application credentials json file to use, if envvar GOOGLE_APPLICATION_CREDENTIALS
            is not set and the code is not running on a GCP machine.
        nocheck: bool
            If True, will not call check_multiplicity (quicker but less secure). Takes the value of
            not Transparentpath._do_check if None (Default value = None)
        notupdatecache: bool
            If True, will not call _invalidate_cache when doing operations on this path (quicker but less secure).
            Takes the value of not Transparentpath._do_update_cache if None (Default value = None)
        update_expire: Optional[int]
            Time in second after which the cache is considered obsolete and must be updated. Takes the value of
            Transparentpath._update_expire if None (Default value = None)
        check_expire: Optional[int]
            Time in second after which the check for multiple existence is considered obsolete and must be updated.
            Takes the value of Transparentpath._check_expire if None (Default value = None)
        when_checked: Optional[dict]
            Dict of the form {&#34;used: True, &#34;created&#34;: True}, that indicates when to check multiplicity of the path.
            Takes the value of Transparentpath._when_checked if None (Default value = None)
        when_updated: Optional[dict]
            Same as when_checked but for cache update.
        enable_caching: bool
            If True, will enable file caching, meaning file content read from a transparentpath will be saved in tmp
            for quicker access later in the code. Default is False.

        kwargs:
            Any optional kwargs valid for `pathlib.Path`
        &#34;&#34;&#34;
        self.enable_caching = enable_caching

        if path is None:
            path = &#34;.&#34;

        if (
            not (type(path) == type(Path(&#34;dummy&#34;)))  # noqa: E721
            and not (type(path) == str)
            and not (type(path) == TransparentPath)
        ):
            raise TypeError(f&#34;Unsupported type {type(path)} for path&#34;)

        # I never remember whether I should use fs=&#39;local&#39; or fs_kind=&#39;local&#39;. That way I don&#39;t need to.
        if fs is None:
            fs = &#34;&#34;
        if &#34;fs_kind&#34; in kwargs and fs == &#34;&#34; and kwargs[&#34;fs_kind&#34;] is not None and kwargs[&#34;fs_kind&#34;] != &#34;&#34;:
            fs = kwargs[&#34;fs_kind&#34;]
            del kwargs[&#34;fs_kind&#34;]
        if bucket == &#34;&#34;:
            bucket = None

        # Copy path completely if it is a TransparentPath and we did not
        # ask for a new file system
        if type(path) == TransparentPath and fs == &#34;&#34;:
            # noinspection PyUnresolvedReferences
            self.bucket = path.bucket
            # noinspection PyUnresolvedReferences
            self.fs_kind = path.fs_kind
            # noinspection PyUnresolvedReferences
            self.fs = copy(path.fs)
            # noinspection PyUnresolvedReferences
            self.nas_dir = path.nas_dir
            # noinspection PyUnresolvedReferences
            self.__path = path.path
            # noinspection PyUnresolvedReferences
            self.sep = path.sep
            # noinspection PyUnresolvedReferences
            self.nocheck = path.nocheck
            # noinspection PyUnresolvedReferences
            self.notupdatecache = path.notupdatecache
            # noinspection PyUnresolvedReferences
            self.last_check = path.last_check
            # noinspection PyUnresolvedReferences
            self.last_update = path.last_update
            # noinspection PyUnresolvedReferences
            self.update_expire = path.update_expire
            # noinspection PyUnresolvedReferences
            self.check_expire = path.check_expire
            # noinspection PyUnresolvedReferences
            self.when_checked = path.when_checked
            # noinspection PyUnresolvedReferences
            self.when_updated = path.when_updated
            # noinspection PyUnresolvedReferences
            self.token = path.token
            return

        # In case we initiate a path containing &#39;gs://&#39;
        if str(path).startswith(TransparentPath.remote_prefix):
            if fs == &#34;local&#34;:
                raise ValueError(
                    &#34;You specified a path starting with &#39;gs://&#39; but ask for it to be local. This is not possible.&#34;
                )
            path, bucket = treat_remote_prefix(path, bucket)
            fs = &#34;gcs&#34;

        self.__path = Path(str(path).encode(&#34;utf-8&#34;).decode(&#34;utf-8&#34;), **kwargs)

        self.token = token
        self.fs, self.fs_kind, b = get_fs(fs, bucket, token, path=self.__path)
        if b != &#34;&#34;:
            bucket = b

        self.bucket = bucket
        self.nas_dir = TransparentPath.nas_dir
        self.nocheck = nocheck if nocheck is not None else not TransparentPath._do_check
        self.notupdatecache = notupdatecache if notupdatecache is not None else not TransparentPath._do_update_cache
        self.last_check = 0
        self.last_update = 0
        self.update_expire = update_expire if update_expire is not None else TransparentPath._update_expire
        self.check_expire = check_expire if check_expire is not None else TransparentPath._check_expire
        self.when_checked = when_checked if when_checked is not None else TransparentPath._when_checked
        self.when_updated = when_updated if when_updated is not None else TransparentPath._when_updated

        if self.fs_kind == &#34;local&#34;:
            self.sep = TransparentPath.LOCAL_SEP
            self.__path = self.__path.absolute()
        else:
            self.sep = &#34;/&#34;

        if collapse:
            self.__path = collapse_ddots(self.__path)

        if self.fs_kind == &#34;local&#34;:

            # ON LOCAL

            if len(self.__path.parts) &gt; 0 and self.__path.parts[0] == &#34;..&#34;:
                raise ValueError(&#34;The path can not start with &#39;..&#39;&#34;)

        else:

            # ON GCS

            # Remove occurences of nas_dir at beginning of path, if any
            if self.nas_dir is not None and (
                str(self.__path).startswith(os.path.abspath(self.nas_dir) + os.sep) or str(self.__path) == self.nas_dir
            ):
                self.__path = self.__path.relative_to(self.nas_dir)

            if str(self.__path) == &#34;.&#34; or str(self.__path) == &#34;/&#34;:
                self.__path = Path(self.bucket)
            elif len(self.__path.parts) &gt; 0:
                if self.__path.parts[0] == &#34;..&#34;:
                    raise ValueError(&#34;Trying to access a path before bucket&#34;)
                if str(self.__path)[0] == &#34;/&#34;:
                    self.__path = Path(str(self.__path)[1:])

                if not str(self.__path.parts[0]) == self.bucket:
                    self.__path = Path(self.bucket) / self.__path
            else:
                self.__path = Path(self.bucket) / self.__path
            # if len(self.__path.parts) &gt; 1 and self.bucket in self.__path.parts[1:]:
            #     raise ValueError(&#34;You should never use your bucket name as a directory or file name.&#34;)

        if self.when_checked[&#34;created&#34;] and not self.nocheck:
            self._check_multiplicity()
        elif self.when_updated[&#34;created&#34;] and not self.notupdatecache:  # Else, because called by check_multiplicity
            self._update_cache()

    @property
    def path(self):
        return self.__path

    @path.setter
    def path(self, value):
        raise AttributeError(&#34;Can not set protected attribute &#39;path&#39;&#34;)

    def __dask_tokenize__(self):
        return hash(self)

    def __contains__(self, item: str) -&gt; bool:
        &#34;&#34;&#34;Overload of &#39;in&#39; operator
        Use __fspath__ instead of str(self) so that any method trying to assess whether the path is on gcs using
        &#39;//&#39; in path will return True.
        &#34;&#34;&#34;
        return item in self.__fspath__()

    # noinspection PyUnresolvedReferences
    def __eq__(self, other: TransparentPath) -&gt; bool:
        &#34;&#34;&#34;Two paths are equal if their absolute pathlib.Path (double dots collapsed) are the same, and all other
        attributes are the same.&#34;&#34;&#34;
        if not isinstance(other, TransparentPath):
            return False
        p1 = collapse_ddots(self)
        p2 = collapse_ddots(other)
        if p1.__fspath__() != p2.__fspath__():
            return False
        if p1.fs_kind != p2.fs_kind:
            return False
        return True

    def __lt__(self, other: TransparentPath) -&gt; bool:
        return str(self) &lt; str(other)

    def __gt__(self, other: TransparentPath) -&gt; bool:
        return str(self) &gt; str(other)

    def __le__(self, other: TransparentPath) -&gt; bool:
        return str(self) &lt;= str(other)

    def __ge__(self, other: TransparentPath) -&gt; bool:
        return str(self) &gt;= str(other)

    def __add__(self, other: str) -&gt; TransparentPath:
        &#34;&#34;&#34;Alias of truediv

        You can do :
        &gt;&gt;&gt; from transparentpath import TransparentPath
        &gt;&gt;&gt; p = TransparentPath(&#34;/chat&#34;)
        &gt;&gt;&gt; p + &#34;chien&#34;
        /chat/chien

        If you want to add a string without having a &#39;/&#39; poping, use &#39;append&#39;:
        &gt;&gt;&gt; from transparentpath import TransparentPath
        &gt;&gt;&gt; p = TransparentPath(&#34;/chat&#34;)
        &gt;&gt;&gt; p.append(&#34;chien&#34;)
        /chatchien
        &#34;&#34;&#34;
        return self.__truediv__(other)

    def __iadd__(self, other: str) -&gt; TransparentPath:
        return self.__itruediv__(other)

    def __radd__(self, other):
        raise TypeError(
            &#34;You cannot div/add by a TransparentPath because they are all absolute path, which would result in a path &#34;
            &#34;before root &#34;
        )

    def __truediv__(self, other: str) -&gt; TransparentPath:
        &#34;&#34;&#34;Overload of the division (&#39;/&#39;) method
        TransparentPath behaves like pathlib.Path in regard to the division :
        it appends the denominator to the numerator.

        Parameters
        ----------
        other: str
            The relative path to append to self

        Returns
        -------
        TransparentPath
            The appended path
        &#34;&#34;&#34;

        if other.startswith(self.sep):
            other = other[1:]

        if type(other) == str:
            return TransparentPath(
                self.__path / other,
                fs=self.fs_kind,
                bucket=self.bucket,
                notupdatecache=self.notupdatecache,
                nocheck=self.nocheck,
                when_checked=self.when_checked,
                when_updated=self.when_updated,
                update_expire=self.update_expire,
                check_expire=self.check_expire,
            )
        else:
            raise TypeError(f&#34;Can not divide a TransparentPath by a {type(other)}, only by a string.&#34;)

    def __itruediv__(self, other: str) -&gt; TransparentPath:
        &#34;&#34;&#34;itruediv will be an actual itruediv only if other is a str&#34;&#34;&#34;

        if other.startswith(self.sep):
            other = other[1:]

        if type(other) == str:
            self.__path /= other
            return self
        else:
            raise TypeError(f&#34;Can not divide a TransparentPath by a {type(other)}, only by a string.&#34;)

    def __rtruediv__(self, other: Union[TransparentPath, Path, str]):
        raise TypeError(
            &#34;You cannot div/add by a TransparentPath because they are all absolute path, which would result in a path &#34;
            &#34;before root &#34;
        )

    def __str__(self) -&gt; str:
        return self.__fspath__()

    def __repr__(self) -&gt; str:
        return str(self.__path)

    def __fspath__(self) -&gt; str:
        if self.fs_kind == &#34;local&#34;:
            return str(self.__path)
        else:
            s = &#34;&#34;.join([TransparentPath.remote_prefix, str(self.__path)])
            if TransparentPath.LOCAL_SEP != &#34;/&#34;:
                s = s.replace(TransparentPath.LOCAL_SEP, &#34;/&#34;)
            return s

    def __hash__(self) -&gt; int:
        &#34;&#34;&#34;Uniaue hash number.

        Two TransarentPath will have a same hash number if their fspath are the same and fs_kind (which will inlude
        the project name if remote) are the same.&#34;&#34;&#34;
        hash_number = int.from_bytes((self.fs_kind + self.__fspath__()).encode(), &#34;little&#34;) + int.from_bytes(
            self.fs_kind.encode(), &#34;little&#34;
        )
        return hash_number

    def __getattr__(self, obj_name: str) -&gt; Any:
        &#34;&#34;&#34;Overload of the __getattr__ method
        Is called when trying to fetch a method or attribute not implemeneted in the class. If it is a method,
        will then execute _obj_missing to check if the method has been translated, or exists in the file system
        object. If it is an attribute, will check whether it exists in pathlib.Path objects, and if so add it to
        self. If this new attribute is a pathlib.Path, casts it into a TransparentPath.


        Parameters
        ----------
        obj_name: str
            The method or attribute name


        Returns
        --------
        Any
            What the method/attribute &#39;obj_name&#39; is supposed to return/be

        &#34;&#34;&#34;

        if callable(self):
            raise AttributeError(f&#34;{obj_name} does not belong to TransparentPath&#34;)

        if obj_name in TransparentPath._attributes:
            raise AttributeError(
                f&#34;Attribute {obj_name} is expected to belong to TransparentPath but is not found. Something somehow &#34;
                f&#34;tried to access this attribute before a proper call to __init__. &#34;
            )

        if obj_name in TransparentPath.translations:
            return lambda *args, **kwargs: self._obj_missing(obj_name, &#34;translate&#34;, *args, **kwargs)

        elif obj_name in dir(self.fs):
            obj = getattr(self.fs, obj_name)
            if not callable(obj):
                exec(f&#34;self.{obj_name} = obj&#34;)
            else:
                return lambda *args, **kwargs: self._obj_missing(obj_name, &#34;fs&#34;, *args, **kwargs)

        elif obj_name in dir(self.__path):
            obj = getattr(self.__path, obj_name)
            if not callable(obj):
                # Fetch the self.path&#39;s attributes to set it to self
                if type(obj) == type(self.__path):  # noqa: E721
                    newpath = TransparentPath(
                        obj,
                        fs=self.fs_kind,
                        bucket=self.bucket,
                        notupdatecache=self.notupdatecache,
                        nocheck=self.nocheck,
                        when_checked=self.when_checked,
                        when_updated=self.when_updated,
                        update_expire=self.update_expire,
                        check_expire=self.check_expire,
                    )
                    setattr(self, obj_name, newpath)
                    return newpath
                elif isinstance(obj, Iterable):
                    obj = self._cast_iterable(obj)
                    setattr(self, obj_name, obj)
                    return obj
                else:
                    setattr(self, obj_name, obj)
                    return obj
            elif self.fs_kind == &#34;local&#34;:
                return lambda *args, **kwargs: self._obj_missing(obj_name, &#34;pathlib&#34;, *args, **kwargs)
            else:
                raise AttributeError(f&#34;{obj_name} is not an attribute nor a method of TransparentPath&#34;)

        elif obj_name in dir(&#34;&#34;):
            obj = getattr(&#34;&#34;, obj_name)
            if not callable(obj):
                # Fetch the string&#39;s attributes to set it to self
                setattr(self, obj_name, obj)
                return obj
            else:
                return lambda *args, **kwargs: self._obj_missing(obj_name, &#34;str&#34;, *args, **kwargs)
        else:
            raise AttributeError(f&#34;{obj_name} is not an attribute nor a method of TransparentPath&#34;)

    # /////////////// #
    # PRIVATE METHODS #
    # /////////////// #

    @staticmethod
    def _set_nas_dir(obj, nas_dir):
        if nas_dir is not None:
            if isinstance(nas_dir, TransparentPath):
                obj.nas_dir = nas_dir.__path
            elif isinstance(nas_dir, str):
                obj.nas_dir = Path(nas_dir)
            else:
                obj.nas_dir = nas_dir

    def _cast_fast(self, path: str) -&gt; TransparentPath:
        return TransparentPath(
            path,
            fs=self.fs_kind,
            nocheck=True,
            notupdatecache=True,
            bucket=self.bucket,
            when_checked=self.when_checked,
            when_updated=self.when_updated,
            update_expire=self.update_expire,
            check_expire=self.check_expire,
        )

    def _cast_slow(self, path: str) -&gt; TransparentPath:
        return TransparentPath(
            path,
            fs=self.fs_kind,
            nocheck=False,
            notupdatecache=False,
            bucket=self.bucket,
            when_checked={&#34;created&#34;: False, &#34;used&#34;: False},
            when_updated={&#34;created&#34;: False, &#34;used&#34;: False},
            update_expire=self.update_expire,
            check_expire=self.check_expire,
        )

    def _obj_missing(self, obj_name: str, kind: str, *args, **kwargs) -&gt; Any:
        &#34;&#34;&#34;Method to catch any call to a method/attribute missing from the class.
        Tries to call the object on the class&#39;s FileSystem object or the instance&#39;s self.path (a pathlib.Path object) if
        FileSystem is local


        Parameters
        ----------
        obj_name: str
            The missing object&#39;s name

        kind: str
            Either &#39;fs&#39;, &#39;pathlib&#39; or &#39;translate&#39;

        args
            args to pass to the object

        kwargs
            kwargs to pass to the object


        Returns
        -------
        Any
            What the missing object is supposed to return

        &#34;&#34;&#34;

        # Append the absolute path to self.path according to whether the object
        # needs it and whether we are in gcs or local
        new_args = self._transform_path(obj_name, *args)

        # Object is a method and exists in FileSystem object but has a
        # different name or its kwargs have different names, so use the
        # MethodTranslator class
        if kind == &#34;translate&#34;:
            translated, new_args, new_kwargs = TransparentPath.translations[obj_name].translate(
                self.fs_kind, *new_args, **kwargs
            )
            if &#34;self&#34; in translated:
                the_method = getattr(TransparentPath, translated.split(&#34;self.&#34;)[1])
                to_ret = the_method(self, *args, **new_kwargs)
                return to_ret
            else:
                the_method = getattr(self.fs, translated)
                to_ret = the_method(*new_args, **new_kwargs)
            return to_ret

        # Here, could be a method or an attribute.
        # It exists in FileSystem and has same name and same kwargs (if is a
        # method).
        elif kind == &#34;fs&#34;:
            the_obj = getattr(self.fs, obj_name)
            if callable(the_obj):
                if len(signature(the_obj).parameters) == 0:
                    to_ret = the_obj()
                else:
                    to_ret = the_obj(*new_args, **kwargs)
            else:
                return the_obj
            return to_ret

        # Method does not exist in FileSystem, but exists in pathlib,
        # so try that instead. Do not use new_args in that case, we do not need
        # absolute path
        elif kind == &#34;pathlib&#34;:
            # If arrives there, then it must be a method. If it had been an
            # attribute, it would have been caught in __getattr__.
            the_method = getattr(Path, obj_name)
            to_ret = the_method(self.__path, *args, **kwargs)
            return to_ret
        elif kind == &#34;str&#34;:
            # If arrives there, then it must be a method, and of str. If it had been an
            # attribute, it would have been caught in __getattr__.
            the_method = getattr(str, obj_name)
            to_ret = the_method(str(self), *args, **kwargs)
            return to_ret
        else:
            raise ValueError(f&#34;Unknown value {kind} for attribute kind&#34;)

    def _transform_path(self, method_name: str, *args: Tuple) -&gt; Tuple:
        &#34;&#34;&#34;
        File system methods take self.path as first argument, so add its absolute path as first argument of args.
        Some, like ls or glob, are given a relative path to append to self.path, so we need to change the first
        element of args from args[0] to self.path / args[0]

        Parameters
        ----------
        method_name: str
            The method name, to check whether it needs to append self.path
            or not

        args: Tuple
            The args to pass to the method

        Returns
        -------
        Tuple
            Either the unchanged args, or args with the first element
            prepended by self, or args with a new first element (self)
        &#34;&#34;&#34;
        new_args = [self]
        if method_name in TransparentPath.method_without_self_path:
            return args
        elif method_name in TransparentPath.method_path_concat:
            # Assumes first given arg in args must be concatenated with
            # absolute self.path
            if len(args) &gt; 0:
                new_args = [str(self / str(args[0]))]
                if len(args) &gt; 1:
                    new_args.append(args[1:])
            new_args = tuple(new_args)
        else:
            # noinspection PyTypeChecker
            new_args = tuple([str(self)] + list(args))
        return new_args

    def _update_cache(self):
        &#34;&#34;&#34;Calls FileSystem&#39;s invalidate_cache() to discard the cache then calls a non-disruptive method (fs.info(
        bucket)) to update it.

        If local, on need to update the chache. Not even sure it needs to be invalidated...
        &#34;&#34;&#34;

        if time() - self.last_update &lt; self.update_expire:
            return

        self.fs.invalidate_cache()
        if &#34;gcs&#34; in self.fs_kind:
            try:
                self.fs.info(self.bucket)
            except FileNotFoundError:
                # noinspection PyStatementEffect
                self.buckets
        self.last_update = time()

    def _check_multiplicity(self) -&gt; None:
        &#34;&#34;&#34;Checks if several objects correspond to the path.
        Raises MultipleExistenceError if so, does nothing if not.
        &#34;&#34;&#34;

        if time() - self.last_check &lt; self.check_expire:
            return

        if not self.notupdatecache:
            self._update_cache()
        if str(self.__path) == self.bucket or str(self.__path) == &#34;/&#34;:
            return
        if not self.exists():
            return

        collapsed = str(collapse_ddots(self.__path / &#34;..&#34;))
        if collapsed == &#34;/&#34;:  # Can not ls on root directory anymore
            return
        thels = self.fs.ls(collapsed)
        if len(thels) &gt; 1:
            thels = [Path(apath).name for apath in thels if Path(apath).name == self.name]
            if len(thels) &gt; 1:
                raise TPMultipleExistenceError(self, thels)

        self.last_check = time()

    def _do_nothing(self) -&gt; None:
        &#34;&#34;&#34;does nothing (you don&#39;t say)&#34;&#34;&#34;
        pass

    # ////////////// #
    # PUBLIC METHODS #
    # ////////////// #

    def get_absolute(self) -&gt; TransparentPath:
        &#34;&#34;&#34;Returns self, since all TransparentPaths are absolute

        Returns
        -------
        TransparentPath
            self

        &#34;&#34;&#34;
        return self

    @property
    def absolute(self) -&gt; TransparentPath:
        &#34;&#34;&#34;Returns self, since all TransparentPaths are absolute

        Returns
        -------
        TransparentPath
            self

        &#34;&#34;&#34;
        return self

    def mkbucket(self, name: Optional[str] = None) -&gt; None:
        raise NotImplementedError

    def rmbucket(self, name: Optional[str] = None) -&gt; None:
        raise NotImplementedError

    def exist(self) -&gt; bool:
        &#34;&#34;&#34;To prevent typo of &#39;exist()&#39; without an -s&#34;&#34;&#34;
        return self.exists()

    def exists(self) -&gt; bool:
        if str(self.path) == &#34;/&#34; and self.fs_kind == &#34;local&#34;:
            return True
        elif self.path == &#34;gs://&#34; and self.fs_kind == &#34;gcs&#34;:
            return True
        updated = False
        if self.when_checked[&#34;used&#34;] and not self.nocheck:
            self._check_multiplicity()
            updated = True
        elif self.when_updated[&#34;used&#34;] and not self.notupdatecache:
            self._update_cache()
            updated = True
        if not self.fs.exists(self.__fspath__()):
            if not updated:
                self._update_cache()
                return self.fs.exists(self.__fspath__())
            else:
                return False
        return True

    def isfile(self) -&gt; bool:
        return self.is_file()

    # noinspection PyUnusedLocal
    def isdir(self, *args, **kwargs) -&gt; bool:
        return self.is_dir()

    # noinspection PyUnusedLocal
    def is_dir(self, *args, **kwargs) -&gt; bool:
        &#34;&#34;&#34;Check if self is a directory.


        Returns
        -------
        bool

        &#34;&#34;&#34;
        if self.fs_kind == &#34;local&#34;:
            if str(self.path) == &#34;/&#34;:
                return True
            return self.__path.is_dir()
        else:
            if not self.exists():
                return False
            if self.is_file():
                return False
            return True

    def is_file(self) -&gt; bool:
        &#34;&#34;&#34;Check if self is a file
        On GCS, leaves are always files even if created with mkdir.


        Returns
        -------
        bool

        &#34;&#34;&#34;

        if not self.exists():
            return False

        if self.fs_kind == &#34;local&#34;:
            return self.__path.is_file()
        else:
            # GCS is shit and sometimes needs to be checked twice
            if self.info()[&#34;type&#34;] == &#34;file&#34; and self.info()[&#34;type&#34;] == &#34;file&#34;:
                return True
            else:
                return False

    def unlink(self, **kwargs) -&gt; None:
        &#34;&#34;&#34;Alias of rm, to match pathlib.Path method&#34;&#34;&#34;
        self.rm(**kwargs)

    def rm(self, absent: str = &#34;raise&#34;, ignore_kind: bool = False, **kwargs) -&gt; None:
        &#34;&#34;&#34;Removes the object pointed to by self if exists.
        Remember that leaves are always files on GCS, so rm will remove the path if it is a leaf on GCS


        Parameters
        ----------
        absent: str
            What to do if trying to remove an item that does not exist. Can
            be &#39;raise&#39; or &#39;ignore&#39; (Default value = &#39;raise&#39;)

        ignore_kind: bool
            If True, will remove anything pointed by self. If False,
            will raise an error if self points to a file and &#39;recursive&#39; was
            specified in kwargs, or if self points to a dir and &#39;recursive&#39;
            was not specified (Default value = False)

        kwargs
            The kwargs to pass to file system&#39;s rm method


        Returns
        -------
        None

        &#34;&#34;&#34;

        if absent != &#34;raise&#34; and absent != &#34;ignore&#34;:
            raise ValueError(f&#34;Unexpected value for argument &#39;absent&#39; : {absent}&#34;)

        # Asked to remove a directory...
        recursive = kwargs.get(&#34;recursive&#34;, False)

        if recursive:
            if not self.is_dir():
                # ...but self points to something that is not a directory!
                if self.exists():
                    # Delete anyway
                    if ignore_kind:
                        del kwargs[&#34;recursive&#34;]
                        self.rm(absent, **kwargs)
                    # or raise
                    else:
                        raise NotADirectoryError(&#34;The path does not point to a directory!&#34;)
                # ...but self points to something that does not exist!
                else:
                    if absent == &#34;raise&#34;:
                        raise NotADirectoryError(&#34;There is no directory here!&#34;)
                    else:
                        return
            # ...deletes the directory
            else:
                try:
                    self.fs.rm(self.__fspath__(), **kwargs)
                except OSError as e:
                    if &#34;not found&#34; in str(e).lower():
                        # It is possible that another parallel program deleted the object, in that case just pass
                        pass
                    else:
                        raise e
        # Asked to remove a file...
        else:
            # ...but self points to a directory!
            if self.is_dir():
                # Delete anyway
                if ignore_kind:
                    kwargs[&#34;recursive&#34;] = True
                    self.rm(absent=absent, ignore_kind=True, **kwargs)
                # or raise
                else:
                    raise IsADirectoryError(&#34;The path points to a directory&#34;)
            else:
                # ... but nothing is at self
                if not self.exists():
                    if absent == &#34;raise&#34;:
                        raise FileNotFoundError(f&#34;Could not find file {self}&#34;)
                    else:
                        return
                else:
                    try:
                        self.fs.rm(self.__fspath__(), **kwargs)
                    except OSError as e:
                        if &#34;not found&#34; in str(e).lower():
                            # It is possible that another parallel program deleted the object, in that case just pass
                            pass
                        else:
                            raise e

    def rmdir(self, absent: str = &#34;raise&#34;, ignore_kind: bool = False) -&gt; None:
        &#34;&#34;&#34;Removes the directory corresponding to self if exists
        Remember that leaves are always files on GCS, so rmdir will never remove a leaf on GCS


        Parameters
        ----------
        absent: str
            What to do if trying to remove an item that does not exist. Can
            be &#39;raise&#39; or &#39;ignore&#39; (Default value = &#39;raise&#39;)

        ignore_kind: bool
            If True, will remove anything pointed by self. If False,
            will raise an error if self points to a file and &#39;recursive&#39; was
            specified in kwargs, or if self point to a dir and &#39;recursive&#39;
            was not specified (Default value = False)

        &#34;&#34;&#34;
        self.rm(absent=absent, ignore_kind=ignore_kind, recursive=True)

    def glob(
        self, wildcard: str = &#34;*&#34;, fast: bool = False, i_am_sure_i_am_a_dir: bool = False
    ) -&gt; Iterator[TransparentPath]:
        &#34;&#34;&#34;Returns a list of TransparentPath matching the wildcard pattern.

        By default, the wildcard is &#39;*&#39;. It means &#39;thepath/*&#39;, so will glob in the directory.

        Parameters
        -----------
        wildcard: str
            The wilcard pattern to match, relative to self (Default value = &#34;*&#34;)

        fast: bool
            If True, does not check multiplicity when converting output paths to TransparentPath, significantly
            speeding up the process (Default value = False)
        i_am_sure_i_am_a_dir: bool
            If True, will not check that self points to a directory. Saves time.


        Returns
        --------
        Iterator[TransparentPath]
            The list of items matching the pattern

        &#34;&#34;&#34;

        if not i_am_sure_i_am_a_dir:
            if not self.is_dir():
                raise NotADirectoryError(&#34;The path must be a directory if you want to glob in it&#34;)

        if wildcard.startswith(&#34;/&#34;) or wildcard.startswith(&#34;\\&#34;):
            wildcard = wildcard[1:]

        if wildcard.startswith(&#34;**/*&#34;):
            wildcard = wildcard.replace(&#34;**/*&#34;, &#34;**&#34;)

        path_to_glob = (self.__path / wildcard).__fspath__()

        try:
            if fast:
                to_ret = map(self._cast_fast, self.fs.glob(path_to_glob))
            else:
                to_ret = map(self._cast_slow, self.fs.glob(path_to_glob))
        except TypeError as e:
            if &#34;list indices must be integers or slices, not str&#34; in str(e):
                to_ret = []
            else:
                raise e
        return to_ret

    def with_suffix(self, suffix: str) -&gt; TransparentPath:
        &#34;&#34;&#34;Returns a new TransparentPath object with a changed suffix
        Uses the with_suffix method of pathlib.Path


        Parameters
        -----------
        suffix: str
            suffix to use, with the dot (&#39;.pdf&#39;, &#39;.py&#39;, etc ..). Can also use &#39;&#39; to remove the suffix.

        Returns
        --------
        TransparentPath

        &#34;&#34;&#34;
        if not suffix.startswith(&#34;.&#34;) and not suffix == &#34;&#34;:
            suffix = f&#34;.{suffix}&#34;
        return TransparentPath(
            self.__path.with_suffix(suffix),
            fs=self.fs_kind,
            bucket=self.bucket,
            notupdatecache=self.notupdatecache,
            nocheck=self.nocheck,
            when_checked=self.when_checked,
            when_updated=self.when_updated,
            update_expire=self.update_expire,
            check_expire=self.check_expire,
        )

    def ls(self, path_to_ls: str = &#34;&#34;, fast: bool = False) -&gt; Iterator[TransparentPath]:
        &#34;&#34;&#34;Unlike glob, if on GCS, will also see directories.


        Parameters
        -----------
        path_to_ls: str
            Path to ls, relative to self (default value = &#34;&#34;)
        fast: bool
            If True, does not check multiplicity when converting output
            paths to TransparentPath, significantly speeding up the process
            (Default value = False)


        Returns
        --------
        Iterator[TransparentPath]

        &#34;&#34;&#34;

        if isinstance(path_to_ls, TransparentPath):
            raise TypeError(&#34;Can not use a TransparentPath as a argument of ls() : TransparentPath are all absolute&#34;)

        if not self.is_dir():
            raise NotADirectoryError(&#34;The path must be a directory if you want to ls in it&#34;)

        if fast:
            to_ret = map(self._cast_fast, self.fs.ls(str(self / path_to_ls)))
        else:
            to_ret = map(self._cast_slow, self.fs.ls(str(self / path_to_ls)))
        return to_ret

    def cd(self, path: Optional[str] = None) -&gt; None:
        &#34;&#34;&#34;cd-like command. Works inplace

        Will collapse double-dots (&#39;..&#39;), so not compatible with symlinks. If path is absolute (starts with &#39;/&#39; or
        bucket name or is empty), will return a path starting from root directory if FileSystem is local, from bucket
        if it is GCS. If passing None or &#34;&#34; , will have the same effect than &#34;/&#34; on GCS, will return the current
        working directory on local. If passing &#34;.&#34;, will return a path at the location of self. Will raise an error
        if trying to access a path before root or bucket.


        Parameters
        ----------
        path: str
            The path to cd to. Absolute, or relative to self.
            (Default value = None)


        Returns
        -------
        None: works inplace

        &#34;&#34;&#34;

        # Will collapse any &#39;..&#39;

        if not isinstance(path, str) or isinstance(path, TransparentPath):
            raise TypeError(&#34;Can only pass a string to TransparentPath&#39;s cd method&#34;)

        path = path.replace(TransparentPath.remote_prefix, &#34;&#34;, 1)

        if &#34;gcs&#34; in self.fs_kind and str(path) == self.bucket or path == &#34;&#34; or str(path) == &#34;/&#34;:
            self.__path = Path(self.bucket)
            return

        # If asked to cd to home, return path script calling directory
        if path == &#34;&#34; or path is None:
            self.__path = Path()
            return

        # noinspection PyUnresolvedReferences
        self.__path = self.__path / path

        if self.fs_kind == &#34;local&#34;:
            # If asked for an absolute path
            if path.startswith(&#34;/&#34;):
                self.__path = Path(path)
                return
            # noinspection PyUnresolvedReferences
            if len(self.__path.parts) == 0:
                return
            # noinspection PyUnresolvedReferences
            if self.__path.parts[0] == &#34;..&#34;:
                raise ValueError(&#34;The first part of a path can not be &#39;..&#39;&#34;)
        else:
            # If asked for an absolute path
            if path.startswith(&#34;/&#34;):
                self.__path = Path(self.bucket) / path[1:]
                return
            # noinspection PyUnresolvedReferences
            if self.__path == 1:  # On gcs, first part is bucket
                return
            # noinspection PyUnresolvedReferences
            if self.__path.parts[1] == &#34;..&#34;:
                raise ValueError(&#34;Trying to access a path before bucket&#34;)

        # noinspection PyUnresolvedReferences
        self.__path = collapse_ddots(self.__path)

    def touch(self, present: str = &#34;ignore&#34;, **kwargs) -&gt; None:
        &#34;&#34;&#34;Creates the file corresponding to self if does not exist.

        Raises FileExistsError if there already is an object that is not a file at self. Default behavior is to
        create parent directories of the file if needed. This can be canceled by passing &#39;create_parents=False&#39;, but
        only if not using GCS, since directories are not a thing on GCS.


        Parameters
        ----------
        present: str
            What to do if there is already something at self. Can be &#34;raise&#34; or &#34;ignore&#34; (Default value = &#34;ignore&#34;)

        kwargs
            The kwargs to pass to file system&#39;s touch method


        Returns
        -------
        None

        &#34;&#34;&#34;

        if present != &#34;raise&#34; and present != &#34;ignore&#34;:
            raise ValueError(f&#34;Unexpected value for argument &#39;present&#39; : {present}&#34;)

        if self.exists():
            if self.is_file() and present == &#34;raise&#34;:
                raise FileExistsError
            elif not self.is_file():
                raise FileExistsError(f&#34;There is already an object at {self} which is not a file.&#34;)
            else:
                return

        for parent in reversed(self.parents):
            p = TransparentPath(
                parent,
                fs=self.fs_kind,
                bucket=self.bucket,
                notupdatecache=self.notupdatecache,
                nocheck=self.nocheck,
                when_checked=self.when_checked,
                when_updated=self.when_updated,
                update_expire=self.update_expire,
                check_expire=self.check_expire,
            )
            if p.is_file():
                raise FileExistsError(f&#34;A parent directory can not be created because there is already a file at {p}&#34;)
            elif not p.exists():
                p.mkdir()

        self.fs.touch(self.__fspath__(), **kwargs)

    def mkdir(self, present: str = &#34;ignore&#34;, **kwargs) -&gt; None:
        &#34;&#34;&#34;Creates the directory corresponding to self if does not exist

        Remember that leaves are always files on GCS, so can not create a directory on GCS. Thus, the function will
        have no effect on GCS.


        Parameters
        ----------
        present: str
            What to do if there is already something at self. Can be &#34;raise&#34; or &#34;ignore&#34; (Default value = &#34;ignore&#34;)

        kwargs
            The kwargs to pass to file system&#39;s mkdir method


        Returns
        -------
        None

        &#34;&#34;&#34;

        if present != &#34;raise&#34; and present != &#34;ignore&#34;:
            raise ValueError(f&#34;Unexpected value for argument &#39;present&#39; : {present}&#34;)

        if self.exists():
            if self.is_dir() and present == &#34;raise&#34;:
                raise FileExistsError(f&#34;There is already a directory at {self}&#34;)
            if not self.is_dir():
                raise FileExistsError(f&#34;There is already an object at {self} and it is not a  directory&#34;)
            return

        for parent in reversed(self.parents):
            thefile = TransparentPath(
                parent,
                fs=self.fs_kind,
                bucket=self.bucket,
                notupdatecache=self.notupdatecache,
                nocheck=self.nocheck,
                when_checked=self.when_checked,
                when_updated=self.when_updated,
                update_expire=self.update_expire,
                check_expire=self.check_expire,
            )
            if thefile.is_file():
                raise FileExistsError(
                    &#34;A parent directory can not be created because there is already a file at&#34; f&#34; {thefile}&#34;
                )

        if self.fs_kind == &#34;local&#34;:
            # Use _obj_missing instead of callign mkdir directly because
            # file systems mkdir has some kwargs with different name than
            # pathlib.Path&#39;s  mkdir, and this is handled in _obj_missing
            self._obj_missing(&#34;mkdir&#34;, kind=&#34;translate&#34;, **kwargs)
        else:
            # Does not mean anything to create a directory on GCS
            pass

    def stat(self) -&gt; dict:
        &#34;&#34;&#34;Calls file system&#39;s stat method and translates the key to os.stat_result() keys

        Returns empty dict of path does not point to anything
        &#34;&#34;&#34;

        if not self.exist():
            return {}

        key_translation = {
            &#34;size&#34;: &#34;st_size&#34;,
            &#34;timeCreated&#34;: &#34;st_ctime&#34;,
            &#34;updated&#34;: &#34;st_mtime&#34;,
            &#34;created&#34;: &#34;st_ctime&#34;,
            &#34;mode&#34;: &#34;st_mode&#34;,
            &#34;uid&#34;: &#34;st_uid&#34;,
            &#34;gid&#34;: &#34;st_gid&#34;,
            &#34;mtime&#34;: &#34;st_mtime&#34;,
        }

        stat = self.fs.stat(self.__fspath__())
        statkeys = list(stat.keys())
        for key in statkeys:
            if key in key_translation:
                if key == &#34;timeCreated&#34; or key == &#34;updated&#34;:
                    dt = datetime.strptime(stat[key], &#34;%Y-%m-%dT%H:%M:%S.%fZ&#34;)
                    stat[key] = dt.timestamp()
                if key == &#34;created&#34; or key == &#34;mtime&#34;:
                    stat[key] = int(stat[key])
                stat[key_translation[key]] = stat[key]

        for key in key_translation.values():
            if key not in stat:
                stat[key] = None

        return stat

    def append(self, other: str) -&gt; TransparentPath:
        return TransparentPath(
            str(self) + other,
            fs=self.fs_kind,
            bucket=self.bucket,
            notupdatecache=self.notupdatecache,
            nocheck=self.nocheck,
            when_checked=self.when_checked,
            when_updated=self.when_updated,
            update_expire=self.update_expire,
            check_expire=self.check_expire,
        )

    def walk(self) -&gt; Iterator[Tuple[TransparentPath, List[TransparentPath], List[TransparentPath]]]:
        &#34;&#34;&#34;Like os.walk, except all outputs are TransparentPaths (so, absolute paths)

        Returns
        -------
        Iterator[Tuple[TransparentPath, List[TransparentPath], List[TransparentPath]]]
            root, dirs and files, like os.walk
        &#34;&#34;&#34;

        if self.when_checked[&#34;used&#34;] and not self.nocheck:
            self._check_multiplicity()
        # No need to update cache for walk

        outputs = self.fs.walk(self.__fspath__())
        for output in outputs:
            root = TransparentPath(
                output[0],
                fs=self.fs_kind,
                bucket=self.bucket,
                notupdatecache=self.notupdatecache,
                nocheck=self.nocheck,
                when_checked=self.when_checked,
                when_updated=self.when_updated,
                update_expire=self.update_expire,
                check_expire=self.check_expire,
            )
            dirs = [root / p for p in output[1]]
            files = [root / p for p in output[2]]
            yield root, dirs, files

    @property
    def buckets(self) -&gt; List[str]:
        if self.fs_kind == &#34;local&#34;:
            return []
        return get_buckets(self.fs)

    def _cast_iterable(self, iter_: Iterable):
        &#34;&#34;&#34;Used by self.walk&#34;&#34;&#34;
        if isinstance(iter_, Path) or isinstance(iter_, TransparentPath):
            return TransparentPath(
                iter_,
                fs=self.fs_kind,
                bucket=self.bucket,
                notupdatecache=self.notupdatecache,
                nocheck=self.nocheck,
                when_checked=self.when_checked,
                when_updated=self.when_updated,
                update_expire=self.update_expire,
                check_expire=self.check_expire,
            )
        elif isinstance(iter_, str):
            return iter_
        elif not isinstance(iter_, Iterable):
            return iter_
        else:
            to_ret = [self._cast_iterable(item) for item in iter_]
            return to_ret

    def caching_ram(self, data, args, kwargs) -&gt; None:
        &#34;&#34;&#34;
        caching for ram
        &#34;&#34;&#34;
        filesize = sys.getsizeof(data)
        if filesize &gt; TransparentPath.caching_max_memory * 1000000:
            warnings.warn(
                f&#34;You are trying to add in cache a file of {filesize / 1000000} MB, but the max memory &#34;
                f&#34;for caching is {TransparentPath.caching_max_memory} MB\nCaching canceled&#34;,
                TPCachingWarning,
            )
        else:
            while TransparentPath.used_memory + filesize &gt; TransparentPath.caching_max_memory * 1000000:
                # Drop oldest file
                byename, byefile = TransparentPath.cached_data_dict.popitem(last=False)
                TransparentPath.used_memory -= sys.getsizeof(byefile)
                warnings.warn(
                    f&#34;You have exceeded the max memory for caching of {TransparentPath.caching_max_memory} MB&#34;
                    f&#34;(old files {TransparentPath.used_memory / 1000000} MB, new file {filesize / 1000000})&#34;
                    f&#34;removing from cach : {byename}&#34;,
                    TPCachingWarning,
                )
            # Adding file to dict and filesize to total used memory
            TransparentPath.used_memory += filesize
            TransparentPath.cached_data_dict[self.__hash__()] = {&#34;data&#34;: data, &#34;args&#34;: args, &#34;kwargs&#34;: kwargs}

    def caching_tmpfile(self, args, kwargs) -&gt; None:
        &#34;&#34;&#34;
        caching for tmpfile
        &#34;&#34;&#34;
        temp_file = tempfile.NamedTemporaryFile(delete=True, suffix=self.suffix)
        self.get(temp_file.name)
        # noinspection PyUnresolvedReferences
        tempfilesize = temp_file.file.tell()
        if tempfilesize &gt; TransparentPath.caching_max_memory * 1000000:
            warnings.warn(
                f&#34;You are trying to add in cache a file of {tempfilesize / 1000000} MB, but the max memory &#34;
                f&#34;for caching is {TransparentPath.caching_max_memory} MB\nCaching canceled&#34;,
                TPCachingWarning,
            )
        else:
            while TransparentPath.used_memory + tempfilesize &gt; TransparentPath.caching_max_memory * 1000000:
                byename, byefile = TransparentPath.cached_data_dict.popitem(last=False)
                byefile[&#34;file&#34;].close()
                TransparentPath.used_memory -= byefile[&#34;memory&#34;]
                warnings.warn(
                    f&#34;You have exceeded the max memory for caching of {TransparentPath.caching_max_memory} MB&#34;
                    f&#34;(old files {TransparentPath.used_memory / 1000000} MB, new file {tempfilesize / 1000000})&#34;
                    f&#34;removing from cach : {byename}&#34;,
                    TPCachingWarning,
                )
                del byefile
            TransparentPath.used_memory += tempfilesize
            TransparentPath.cached_data_dict[self.__hash__()] = {
                &#34;file&#34;: temp_file,
                &#34;memory&#34;: tempfilesize,
                &#34;args&#34;: args,
                &#34;kwargs&#34;: kwargs,
            }

    def caching_saver(self, data, args, kwargs) -&gt; None:
        &#34;&#34;&#34;
        Save fetched data from read in tmp file or dict,
         if total of cach does not exceed caching_max_memory else remove oldest data

        To use ram caching set self.caching to &#34;ram&#34;, to use tmp file caching set self.caching to &#34;tmpfile&#34;

        To disable caching, set self.caching to something else or self.enable_caching to False

        TransparentPath.caching_max_memory is in MB
        &#34;&#34;&#34;
        if self.enable_caching:
            if self.caching == &#34;ram&#34;:
                self.caching_ram(data, args, kwargs)

            elif self.caching == &#34;tmpfile&#34; and self.fs_kind != &#34;local&#34;:
                self.caching_tmpfile(args, kwargs)

    def uncache(self) -&gt; None:
        &#34;&#34;&#34;
        remove data from cache
        &#34;&#34;&#34;
        if self.enable_caching:
            if self.__hash__() in TransparentPath.cached_data_dict.keys():
                TransparentPath.cached_data_dict.pop(self.__hash__())
            else:
                warnings.warn(f&#34;{self} is not in cache&#34;, TPCachingWarning)

    def refresh_cache(self) -&gt; None:
        &#34;&#34;&#34;
        update tp
        &#34;&#34;&#34;
        if self.enable_caching:
            if self.__hash__() in TransparentPath.cached_data_dict.keys():
                arg = TransparentPath.cached_data_dict[self.__hash__()][&#34;arg&#34;]
                kwarg = TransparentPath.cached_data_dict[self.__hash__()][&#34;kwarg&#34;]
                self.uncache()
                self.read(*arg, **kwarg)
            else:
                warnings.warn(f&#34;{self.__hash__()} is not in cache&#34;, TPCachingWarning)

    def change_suffix(self, suffix: str) -&gt; None:
        if not suffix.startswith(&#34;.&#34;):
            suffix = f&#34;.{suffix}&#34;

        self.path = self.path.with_suffix(suffix)
        if self.when_checked[&#34;created&#34;] and not self.nocheck:
            self._check_multiplicity()
        elif self.when_updated[&#34;created&#34;] and not self.notupdatecache:  # Else, because called by check_multiplicity
            self._update_cache()

    def read(
        self,
        *args,
        get_obj: bool = False,
        use_pandas: bool = False,
        use_dask: bool = False,
        **kwargs,
    ) -&gt; Any:
        &#34;&#34;&#34;Method used to read the content of the file located at self

        Will raise FileNotFound error if there is no file. Calls a specific method to read self based on the suffix
        of self.path:
            1: .csv : will use pandas&#39;s read_csv
            2: .parquet : will use pandas&#39;s read_parquet with pyarrow engine
            3: .hdf5 or .h5 : will use h5py.File or pd.HDFStore (if use_pandas = True). Since it does not support
            remote file systems, the file will be downloaded localy in a tmp file read, then removed.
            4: .json : will use open() method to get file content then json.loads to get a dict
            5: .xlsx : will use pd.read_excel
            6: any other suffix : will return a IO buffer to read from, or the string contained in the file if
            get_obj is False.

        For any of the reading method, the appropriate packages need to have been installed by calling
        `pip install transparentpath[something]`
        The possibilities for &#39;something&#39; are &#39;pandas-csv&#39;, &#39;pandas-parquet&#39;, &#39;pandas-excel&#39;, &#39;hdf5&#39;, &#39;json&#39;, &#39;dask&#39;.
        You can install all possible packages by putting &#39;all&#39; in place of &#39;something&#39;.

        The default installation of transperantpath is &#39;vanilla&#39;, which will only support read and write of text
         or binary files, and the use of with open(...).

        If self.enable_caching is True, will either save in tmp file (if self.caching == &#34;tmpfile&#34;) or store the read
        data in a dict (if self.caching == &#34;ram&#34;), then if the path have already been read, will just return the
        previously stored data

        Parameters
        ----------
        get_obj: bool
            Only relevant for files that are not csv, parquet nor HDF5. If True returns the IO Buffer,
            else the string contained in the IO Buffer (Default value = False)
        use_pandas: bool
            Must pass it as True if hdf5 file was written using HDFStore and not h5py.File (Default value = False)
        use_dask: bool
            To return a Dask DataFrame instead of a pandas DataFrame. Only makes sense if file suffix is xlsx, csv,
            parquet. (Default value = False)
        args:
            any args to pass to the underlying reading method
        kwargs:
            any kwargs to pass to the underlying reading method

        Returns
        -------
        Any
        &#34;&#34;&#34;
        if self.enable_caching:
            if self.caching == &#34;ram&#34;:
                if self.__hash__() in TransparentPath.cached_data_dict.keys():
                    return TransparentPath.cached_data_dict[self.__hash__()][&#34;data&#34;]
            elif self.caching == &#34;tmpfile&#34; and self.fs_kind != &#34;local&#34;:
                if self.__hash__() in TransparentPath.cached_data_dict.keys():
                    return TransparentPath(
                        TransparentPath.cached_data_dict[self.__hash__()][&#34;file&#34;].name, fs=&#34;local&#34;
                    ).read(*args, get_obj, use_pandas, use_dask, **kwargs)
        if self.suffix == &#34;.csv&#34;:
            ret = self.read_csv(use_dask=use_dask, **kwargs)
            self.caching_saver(
                ret, args, kwargs.update({&#34;use_pandas&#34;: use_pandas, &#34;use_dask&#34;: use_dask, &#34;get_obj&#34;: get_obj})
            )
            return ret
        elif self.suffix == &#34;.parquet&#34;:
            index_col = None
            if &#34;index_col&#34; in kwargs:
                index_col = kwargs[&#34;index_col&#34;]
                del kwargs[&#34;index_col&#34;]
            # noinspection PyNoneFunctionAssignment
            content = self.read_parquet(use_dask=use_dask, **kwargs)
            if index_col:
                # noinspection PyUnresolvedReferences
                content.set_index(content.columns[index_col])
            self.caching_saver(
                content, args, kwargs.update({&#34;use_pandas&#34;: use_pandas, &#34;use_dask&#34;: use_dask, &#34;get_obj&#34;: get_obj})
            )
            return content
        elif self.suffix == &#34;.hdf5&#34; or self.suffix == &#34;.h5&#34;:
            ret = self.read_hdf5(use_pandas=use_pandas, use_dask=use_dask, **kwargs)
            self.caching_saver(
                ret, args, kwargs.update({&#34;use_pandas&#34;: use_pandas, &#34;use_dask&#34;: use_dask, &#34;get_obj&#34;: get_obj})
            )
            return ret
        elif self.suffix == &#34;.json&#34;:
            ret = self.read_json(*args, get_obj=get_obj, **kwargs)
            self.caching_saver(
                ret, args, kwargs.update({&#34;use_pandas&#34;: use_pandas, &#34;use_dask&#34;: use_dask, &#34;get_obj&#34;: get_obj})
            )
            return ret
        elif self.suffix in [&#34;.xlsx&#34;, &#34;.xls&#34;, &#34;.xlsm&#34;]:
            ret = self.read_excel(use_dask=use_dask, **kwargs)
            self.caching_saver(
                ret, args, kwargs.update({&#34;use_pandas&#34;: use_pandas, &#34;use_dask&#34;: use_dask, &#34;get_obj&#34;: get_obj})
            )
            return ret
        else:
            ret = self.read_text(*args, get_obj=get_obj, **kwargs)
            self.caching_saver(
                ret, args, kwargs.update({&#34;use_pandas&#34;: use_pandas, &#34;use_dask&#34;: use_dask, &#34;get_obj&#34;: get_obj})
            )
            return ret

    # noinspection PyUnresolvedReferences
    def write(
        self,
        data: Any,
        *args,
        set_name: str = &#34;data&#34;,
        use_pandas: bool = False,
        overwrite: bool = True,
        present: str = &#34;ignore&#34;,
        make_parents: bool = False,
        **kwargs,
    ) -&gt; Union[None, &#34;pd.HDFStore&#34;, &#34;h5py.File&#34;]:
        &#34;&#34;&#34;Method used to write the content of the file located at self
        Calls a specific method to write data based on the suffix of self.path:
            1: .csv : will use pandas&#39;s to_csv
            2: .parquet : will use pandas&#39;s to_parquet with pyarrow engine
            3: .hdf5 or .h5 : will use h5py.File. Since it does not support remote file systems, the file will be
            created localy in a tmp filen written to, then uploaded and removed localy.
            4: .json : will use jsonencoder.JSONEncoder class. Works with DataFrames and np.ndarrays too.
            5: .xlsx : will use pandas&#39;s to_excel
            5: any other suffix : uses self.open to write to an IO Buffer
        Parameters
        ----------
        data: Any
            The data to write
        set_name: str
            Name of the dataset to write. Only relevant if using HDF5 (Default value = &#39;data&#39;)
        use_pandas: bool
            Must pass it as True if hdf file must be written using HDFStore and not h5py.File
        overwrite: bool
            If True, any existing file will be overwritten. Only relevant for csv, hdf5 and parquet files,
            since others use the &#39;open&#39; method, which args already specify what to do (Default value = True).
        present: str
            Indicates what to do if overwrite is False and file is present. Here too, only relevant for csv,
            hsf5 and parquet files.
        make_parents: bool
            If True and if the parent arborescence does not exist, it is created. (Default value = False)
        args:
            any args to pass to the underlying writting method
        kwargs:
            any kwargs to pass to the underlying reading method
        Returns
        -------
        Union[None, pd.HDFStore, h5py.File]
        &#34;&#34;&#34;
        # Update cache and/or check multiplicity are called inside each specific reading method

        if make_parents and not self.parent.is_dir():
            self.parent.mkdir()

        if self.suffix != &#34;.hdf5&#34; and self.suffix != &#34;.h5&#34; and data is None:
            data = args[0]
            args = args[1:]

        if self.suffix == &#34;.csv&#34;:
            ret = self.to_csv(
                data=data,
                overwrite=overwrite,
                present=present,
                **kwargs,
            )
            if ret is not None:
                # To skip the assert at the end of the function. Indeed if something is returned it means we used
                # Dask, which will have written files with a different name than self, so the assert would fail.
                return
        elif self.suffix == &#34;.parquet&#34;:
            self.to_parquet(
                data=data,
                overwrite=overwrite,
                present=present,
                **kwargs,
            )
            if &#34;dask&#34; in str(type(data)):
                # noinspection PyUnresolvedReferences
                assert self.with_suffix(&#34;&#34;).is_dir(exist=True)
                return
        elif self.suffix == &#34;.hdf5&#34; or self.suffix == &#34;.h5&#34;:
            ret = self.to_hdf5(
                data=data,
                set_name=set_name,
                use_pandas=use_pandas,
                **kwargs,
            )
            if ret is not None:
                # will not cache the changes for they will happen outside TransparentPath
                return ret
        elif self.suffix == &#34;.json&#34;:
            self.to_json(
                data=data,
                overwrite=overwrite,
                present=present,
                **kwargs,
            )
        elif self.suffix == &#34;.txt&#34;:
            self.write_stuff(
                *args,
                data=data,
                overwrite=overwrite,
                present=present,
                **kwargs,
            )
        elif self.suffix in [&#34;.xlsx&#34;, &#34;.xls&#34;, &#34;.xlsm&#34;]:
            self.to_excel(
                data=data,
                overwrite=overwrite,
                present=present,
                **kwargs,
            )
        else:
            self.write_bytes(
                *args,
                data=data,
                overwrite=overwrite,
                present=present,
                **kwargs,
            )
        self.update_tpcache(data)
        assert self.is_file()

    def update_tpcache(self, data) -&gt; None:
        if self.enable_caching:
            if self.caching == &#34;ram&#34;:
                if self.__hash__() in TransparentPath.cached_data_dict.keys():
                    TransparentPath.cached_data_dict[self.__hash__()][&#34;data&#34;] = data
            elif self.caching == &#34;tmpfile&#34; and self.fs_kind != &#34;local&#34;:
                if self.__hash__() in TransparentPath.cached_data_dict.keys():
                    TransparentPath(TransparentPath.cached_data_dict[self.__hash__()][&#34;file&#34;].name, fs=&#34;local&#34;).write(
                        data
                    )

    @property
    def download(self) -&gt; Union[None, str]:
        &#34;&#34;&#34;Returns a clickable link to download the file from GCS.

        Returns None if the path does not correspond to an existing file on GCS.
        &#34;&#34;&#34;
        if self.fs_kind.startswith(&#34;gcs&#34;) and self.is_file():
            obj = str(self).replace(TransparentPath.remote_prefix, &#34;&#34;).replace(&#34; &#34;, &#34;%20&#34;)
            return f&#34;https://storage.cloud.google.com/{obj}&#34;
        return None

    @property
    def url(self) -&gt; Union[None, str]:
        &#34;&#34;&#34;Returns a clickable link to open the path in GCS

        Returns None if the path does not correspond to an existing file or directory.
        &#34;&#34;&#34;
        obj = str(self).replace(TransparentPath.remote_prefix, &#34;&#34;).replace(&#34; &#34;, &#34;%20&#34;)
        if self.fs_kind.startswith(&#34;gcs&#34;):
            project = self.fs.project
            if self.is_file():
                prefix = &#34;https://console.cloud.google.com/storage/browser/_details/&#34;
                postfix = f&#34;;tab=live_object?project={project}&#34;
            elif self.is_dir():
                prefix = &#34;https://console.cloud.google.com/storage/browser/&#34;
                postfix = f&#34;;tab=objects?project={project}&#34;
            else:
                return None
        else:
            if not self.exists():
                return None
            return f&#34;file://{obj}&#34;
        return f&#34;{prefix}{obj}{postfix}&#34;

    # READ CSV

    def read_csv(self, *args, **kwargs) -&gt; Any:
        use_dask = False
        if &#34;use_dask&#34; in kwargs:
            use_dask = kwargs[&#34;use_dask&#34;]
            del kwargs[&#34;use_dask&#34;]
        if use_dask:
            return self.read_csv_dask(*args, **kwargs)
        else:
            return self.read_csv_classic(*args, **kwargs)

    def read_csv_dask(self, *args, **kwargs) -&gt; Any:
        &#34;&#34;&#34;Overloaded in `transparentpath.io.dask.read_csv`&#34;&#34;&#34;
        raise ImportError(errormessage(&#34;dask&#34;))

    def read_csv_classic(self, *args, **kwargs) -&gt; Any:
        &#34;&#34;&#34;Overloaded in `transparentpath.io.pandas.read`&#34;&#34;&#34;
        raise ImportError(errormessage(&#34;pandas&#34;))

    # READ HDF5

    def read_hdf5(self, *args, **kwargs) -&gt; Any:
        use_dask = False
        if &#34;use_dask&#34; in kwargs:
            use_dask = kwargs[&#34;use_dask&#34;]
            del kwargs[&#34;use_dask&#34;]
        if use_dask:
            return self.read_hdf5_dask(*args, **kwargs)
        else:
            return self.read_hdf5_classic(*args, **kwargs)

    def read_hdf5_dask(self, *args, **kwargs) -&gt; Any:
        &#34;&#34;&#34;Overloaded in `transparentpath.io.dask.read_hdf5`&#34;&#34;&#34;
        raise ImportError(errormessage(&#34;dask,hdf5&#34;))

    def read_hdf5_classic(self, *args, **kwargs) -&gt; Any:
        &#34;&#34;&#34;Overloaded in `transparentpath.io.hdf5.read`&#34;&#34;&#34;
        raise ImportError(errormessage(&#34;hdf5&#34;))

    # READ EXCEL

    def read_excel(self, *args, **kwargs) -&gt; Any:
        use_dask = False
        if &#34;use_dask&#34; in kwargs:
            use_dask = kwargs[&#34;use_dask&#34;]
            del kwargs[&#34;use_dask&#34;]
        if use_dask:
            return self.read_excel_dask(*args, **kwargs)
        else:
            return self.read_excel_classic(*args, **kwargs)

    def read_excel_dask(self, *args, **kwargs) -&gt; Any:
        &#34;&#34;&#34;Overloaded in `transparentpath.io.dask.read_excel`&#34;&#34;&#34;
        raise ImportError(errormessage(&#34;dask,excel&#34;))

    def read_excel_classic(self, *args, **kwargs) -&gt; Any:
        &#34;&#34;&#34;Overloaded in `transparentpath.io.excel.read`&#34;&#34;&#34;
        raise ImportError(errormessage(&#34;excel&#34;))

    # READ PARQUET

    def read_parquet(self, *args, **kwargs):
        use_dask = False
        if &#34;use_dask&#34; in kwargs:
            use_dask = kwargs[&#34;use_dask&#34;]
            del kwargs[&#34;use_dask&#34;]
        if use_dask:
            return self.read_parquet_dask(*args, **kwargs)
        else:
            return self.read_parquet_classic(*args, **kwargs)

    def read_parquet_dask(self, *args, **kwargs) -&gt; Any:
        &#34;&#34;&#34;Overloaded in `transparentpath.io.dask.read_parquet`&#34;&#34;&#34;
        raise ImportError(errormessage(&#34;dask,parquet&#34;))

    def read_parquet_classic(self, *args, **kwargs) -&gt; Any:
        &#34;&#34;&#34;Overloaded in `transparentpath.io.parquet.read`&#34;&#34;&#34;
        raise ImportError(errormessage(&#34;parquet&#34;))

    # READ JSON

    def read_json(self, *args, **kwargs) -&gt; Any:
        &#34;&#34;&#34;Overloaded in `transparentpath.io.json.read`&#34;&#34;&#34;
        raise ImportError(errormessage(&#34;json&#34;))

    # WRITE CSV

    def to_csv(self, data, *args, **kwargs):
        if &#34;dask&#34; in str(type(data)):
            return self.to_csv_dask(data, *args, **kwargs)
        else:
            self.to_csv_classic(data, *args, **kwargs)

    def to_csv_classic(self, *args, **kwargs):
        &#34;&#34;&#34;Overloaded in `transparentpath.io.pandas.write`&#34;&#34;&#34;
        raise ImportError(errormessage(&#34;pandas&#34;))

    def to_csv_dask(self, *args, **kwargs):
        &#34;&#34;&#34;Overloaded in `transparentpath.io.dask.write_csv`&#34;&#34;&#34;
        raise ImportError(errormessage(&#34;dask&#34;))

    # WRITE HDF5

    def to_hdf5(self, data, *args, **kwargs):
        if &#34;dask&#34; in str(type(data)):
            return self.to_hdf5_dask(data, *args, **kwargs)
        else:
            return self.to_hdf5_classic(data, *args, **kwargs)

    def to_hdf5_classic(self, *args, **kwargs):
        &#34;&#34;&#34;Overloaded in `transparentpath.io.hdf5.write`&#34;&#34;&#34;
        raise ImportError(errormessage(&#34;hdf5&#34;))

    def to_hdf5_dask(self, *args, **kwargs):
        &#34;&#34;&#34;Overloaded in `transparentpath.io.dask.write_hdf5`&#34;&#34;&#34;
        raise ImportError(errormessage(&#34;dask,hdf5&#34;))

    # WRITE EXCEL

    def to_excel(self, data, *args, **kwargs):
        if &#34;dask&#34; in str(type(data)):
            self.to_excel_dask(data, *args, **kwargs)
        else:
            self.to_excel_classic(data, *args, **kwargs)

    def to_excel_classic(self, *args, **kwargs):
        &#34;&#34;&#34;Overloaded in `transparentpath.io.excel.write`&#34;&#34;&#34;
        raise ImportError(errormessage(&#34;excel&#34;))

    def to_excel_dask(self, *args, **kwargs):
        &#34;&#34;&#34;Overloaded in `transparentpath.io.dask.write_excel`&#34;&#34;&#34;
        raise ImportError(errormessage(&#34;dask,excel&#34;))

    # WRITE PARQUET

    def to_parquet(self, data, *args, **kwargs):
        if &#34;dask&#34; in str(type(data)):
            self.to_parquet_dask(data, *args, **kwargs)
        else:
            self.to_parquet_classic(data, *args, **kwargs)

    def to_parquet_classic(self, *args, **kwargs):
        &#34;&#34;&#34;Overloaded in `transparentpath.io.parquet.write`&#34;&#34;&#34;
        raise ImportError(errormessage(&#34;parquet&#34;))

    def to_parquet_dask(self, *args, **kwargs):
        &#34;&#34;&#34;Overloaded in `transparentpath.io.dask.write_parquet`&#34;&#34;&#34;
        raise ImportError(errormessage(&#34;dask,parquet&#34;))

    def to_json(self, data, *args, **kwargs):
        &#34;&#34;&#34;Overloaded in `transparentpath.io.json.write`&#34;&#34;&#34;
        raise ImportError(errormessage(&#34;json&#34;))

    def to_plotly_json(self):
        &#34;&#34;&#34;Overloaded in `transparentpath.io.json.to_plotly_json`&#34;&#34;&#34;
        raise ImportError(errormessage(&#34;json&#34;))


# Do imports from detached files here because some of them import TransparentPath and need it fully declared.

# noinspection PyProtectedMember
from ..io._io import put, get, mv, cp, overload_open, read_text, write_stuff, write_bytes

# noinspection PyUnresolvedReferences, PyProtectedMember
from ..io import _zipfile

overload_open()
setattr(TransparentPath, &#34;put&#34;, put)
setattr(TransparentPath, &#34;get&#34;, get)
setattr(TransparentPath, &#34;mv&#34;, mv)
setattr(TransparentPath, &#34;cp&#34;, cp)
setattr(TransparentPath, &#34;read_text&#34;, read_text)
setattr(TransparentPath, &#34;write_stuff&#34;, write_stuff)
setattr(TransparentPath, &#34;write_bytes&#34;, write_bytes)

try:
    # noinspection PyUnresolvedReferences,PyProtectedMember
    from transparentpath.io._joblib_load import overload_joblib_load

    overload_joblib_load()
except ImportError:
    pass

try:
    # noinspection PyUnresolvedReferences,PyProtectedMember
    from transparentpath.io._json import read, write, to_plotly_json

    setattr(TransparentPath, &#34;read_json&#34;, read)
    setattr(TransparentPath, &#34;to_json&#34;, write)
    setattr(TransparentPath, &#34;to_plotly_json&#34;, to_plotly_json)
except ImportError:
    pass

try:
    # noinspection PyUnresolvedReferences,PyProtectedMember
    from ..io._pandas import read, write

    setattr(TransparentPath, &#34;read_csv_classic&#34;, read)
    setattr(TransparentPath, &#34;to_csv_classic&#34;, write)
except ImportError:
    pass

try:
    # noinspection PyUnresolvedReferences,PyProtectedMember
    from ..io._hdf5 import read, write

    setattr(TransparentPath, &#34;read_hdf5_classic&#34;, read)
    setattr(TransparentPath, &#34;to_hdf5_classic&#34;, write)
except ImportError:
    pass

try:
    # noinspection PyUnresolvedReferences,PyProtectedMember
    from ..io._parquet import read, write

    setattr(TransparentPath, &#34;read_parquet_classic&#34;, read)
    setattr(TransparentPath, &#34;to_parquet_classic&#34;, write)
except ImportError:
    pass

try:
    # noinspection PyUnresolvedReferences,PyProtectedMember
    from ..io._excel import read, write

    setattr(TransparentPath, &#34;read_excel_classic&#34;, read)
    setattr(TransparentPath, &#34;to_excel_classic&#34;, write)
except ImportError:
    pass

try:
    # noinspection PyProtectedMember
    from ..io._dask import (
        read_csv,
        write_csv,
        read_hdf5,
        write_hdf5,
        read_excel,
        write_excel,
        read_parquet,
        write_parquet,
    )

    setattr(TransparentPath, &#34;read_csv_dask&#34;, read_csv)
    setattr(TransparentPath, &#34;to_csv_dask&#34;, write_csv)
    setattr(TransparentPath, &#34;read_hdf5_dask&#34;, read_hdf5)
    setattr(TransparentPath, &#34;to_hdf5_dask&#34;, write_hdf5)
    setattr(TransparentPath, &#34;read_excel_dask&#34;, read_excel)
    setattr(TransparentPath, &#34;to_excel_dask&#34;, write_excel)
    setattr(TransparentPath, &#34;read_parquet_dask&#34;, read_parquet)
    setattr(TransparentPath, &#34;to_parquet_dask&#34;, write_parquet)
except ImportError:
    pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="transparentpath.gcsutils.transparentpath.check_bucket"><code class="name flex">
<span>def <span class="ident">check_bucket</span></span>(<span>bucket: Optional[str]) ‑> Optional[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Check that the bucket exists in an initiated file system and returns the corresponding file system's name,
or raises NotADirectoryError.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_bucket(bucket: Union[str, None]) -&gt; Union[str, None]:
    &#34;&#34;&#34;Check that the bucket exists in an initiated file system and returns the corresponding file system&#39;s name,
    or raises NotADirectoryError.&#34;&#34;&#34;
    if bucket is None:
        return None
    bucket = str(bucket)
    if not bucket.endswith(&#34;/&#34;):
        bucket += &#34;/&#34;
    fs = None
    for proj in TransparentPath.buckets_in_project:
        if bucket in TransparentPath.buckets_in_project[proj]:
            fs = proj
            break
    return fs</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.check_kwargs"><code class="name flex">
<span>def <span class="ident">check_kwargs</span></span>(<span>method: Callable, kwargs: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Takes as argument a method and some kwargs. Will look in the method signature and return in two separate dict
the kwargs that are in the signature and those that are not.</p>
<p>If the method does not return any signature or if it explicitely accepts **kwargs, does not do anything</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_kwargs(method: Callable, kwargs: dict):
    &#34;&#34;&#34;Takes as argument a method and some kwargs. Will look in the method signature and return in two separate dict
    the kwargs that are in the signature and those that are not.

    If the method does not return any signature or if it explicitely accepts **kwargs, does not do anything
    &#34;&#34;&#34;
    unexpected_kwargs = []
    s = &#34;&#34;
    try:
        sig = signature(method)
        if &#34;kwargs&#34; in sig.parameters or &#34;kwds&#34; in sig.parameters:
            return
        for arg in kwargs:
            if arg not in sig.parameters:
                unexpected_kwargs.append(f&#34;{arg}={kwargs[arg]}&#34;)

        if len(unexpected_kwargs) &gt; 0:
            s = f&#34;You provided unexpected kwargs for method {method.__name__}:&#34;
            s = &#34;\n  - &#34;.join([s] + unexpected_kwargs)
    except ValueError:
        return

    if s != &#34;&#34;:
        raise ValueError(s)</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.collapse_ddots"><code class="name flex">
<span>def <span class="ident">collapse_ddots</span></span>(<span>path: Union[pathlib.Path, <a title="transparentpath.gcsutils.transparentpath.TransparentPath" href="#transparentpath.gcsutils.transparentpath.TransparentPath">TransparentPath</a>, str]) ‑> <a title="transparentpath.gcsutils.transparentpath.TransparentPath" href="#transparentpath.gcsutils.transparentpath.TransparentPath">TransparentPath</a></span>
</code></dt>
<dd>
<div class="desc"><p>Collapses the double-dots (..) in the path</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>Union[Path, <a title="transparentpath.gcsutils.transparentpath.TransparentPath" href="#transparentpath.gcsutils.transparentpath.TransparentPath">TransparentPath</a>, str]</code></dt>
<dd>The path containing double-dots</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath" href="#transparentpath.gcsutils.transparentpath.TransparentPath">TransparentPath</a></code></dt>
<dd>The collapsed path.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collapse_ddots(path: Union[Path, TransparentPath, str]) -&gt; TransparentPath:
    &#34;&#34;&#34;Collapses the double-dots (..) in the path

    Parameters
    ----------
    path: Union[Path, TransparentPath, str]
        The path containing double-dots

    Returns
    -------
    TransparentPath
        The collapsed path.

    &#34;&#34;&#34;
    # noinspection PyUnresolvedReferences
    thetype = path.fs_kind if type(path) == TransparentPath else None
    # noinspection PyUnresolvedReferences
    thebucket = path.bucket if type(path) == TransparentPath else None
    # noinspection PyUnresolvedReferences
    notupdatecache = path.notupdatecache if type(path) == TransparentPath else None
    # noinspection PyUnresolvedReferences
    when_checked = path.when_checked if type(path) == TransparentPath else None
    # noinspection PyUnresolvedReferences
    when_updated = path.when_updated if type(path) == TransparentPath else None
    # noinspection PyUnresolvedReferences
    update_expire = path.update_expire if type(path) == TransparentPath else None
    # noinspection PyUnresolvedReferences
    check_expire = path.check_expire if type(path) == TransparentPath else None
    # noinspection PyUnresolvedReferences

    newpath = Path(path) if type(path) == str else path

    if str(newpath) == &#34;..&#34; or str(newpath) == &#34;/..&#34;:
        raise ValueError(&#34;Can not go before root&#34;)

    while &#34;..&#34; in newpath.parts:
        # noinspection PyUnresolvedReferences
        newnewpath = Path(newpath.parts[0])
        for part in newpath.parts[1:]:
            if part == &#34;..&#34;:
                newnewpath = newnewpath.parent
            else:
                newnewpath /= part
        newpath = newnewpath

    if str(newpath) == str(path):
        return path
    return (
        TransparentPath(
            newpath,
            collapse=False,
            nocheck=True,
            fs=thetype,
            bucket=thebucket,
            notupdatecache=notupdatecache,
            when_checked=when_checked,
            when_updated=when_updated,
            update_expire=update_expire,
            check_expire=check_expire,
        )
        if thetype is not None
        else newpath
    )</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.errorfunction"><code class="name flex">
<span>def <span class="ident">errorfunction</span></span>(<span>which) ‑> Callable</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def errorfunction(which) -&gt; Callable:
    # noinspection PyUnusedLocal
    def _errorfunction(*args, **kwargs):
        raise ImportError(errormessage(which))

    return _errorfunction</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.errormessage"><code class="name flex">
<span>def <span class="ident">errormessage</span></span>(<span>which) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def errormessage(which) -&gt; str:
    return (
        f&#34;Support for {which} does not seem to be installed for TransparentPath.\n&#34;
        f&#34;You can change that by running &#39;pip install transparentpath[{which}]&#39;.&#34;
    )</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.extract_fs_name"><code class="name flex">
<span>def <span class="ident">extract_fs_name</span></span>(<span>token: str = None) ‑> Tuple[str, str, Optional[str]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_fs_name(token: str = None) -&gt; Tuple[str, str, Union[str, None]]:
    if token is None and &#34;GOOGLE_APPLICATION_CREDENTIALS&#34; not in os.environ:
        fs = gcsfs.GCSFileSystem()
        project = fs.project
        if (
            project is None
            or fs.credentials is None
            or not hasattr(fs.credentials.credentials, &#34;service_account_email&#34;)
            or fs.credentials.credentials.service_account_email is None
        ):
            raise EnvironmentError(
                &#34;If no token is explicitely specified and GOOGLE_APPLICATION_CREDENTIALS environnement variable is not&#34;
                &#34; set, you need to have done gcloud init or to be on GCP already to create a TransparentPath&#34;
            )
        email = fs.credentials.credentials.service_account_email
        return f&#34;gcs_{project}_{email}&#34;, project, None
    elif token is None:
        token = os.getenv(&#34;GOOGLE_APPLICATION_CREDENTIALS&#34;)

    token = token.strip()
    if not TransparentPath(token, fs=&#34;local&#34;, nocheck=True, notupdatecache=True).is_file():
        raise FileNotFoundError(f&#34;Credential file {token} not found&#34;)
    content = json.load(open(token))
    if &#34;project_id&#34; not in content:
        raise ValueError(f&#34;Credential file {token} does not contain project_id key.&#34;)
    if &#34;client_email&#34; not in content:
        raise ValueError(f&#34;Credential file {token} does not contain client_email key.&#34;)

    fs_name = f&#34;gcs_{content[&#39;project_id&#39;]}_{content[&#39;client_email&#39;]}&#34;
    TransparentPath.tokens[fs_name] = token
    return fs_name, content[&#34;project_id&#34;], token</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.get_buckets"><code class="name flex">
<span>def <span class="ident">get_buckets</span></span>(<span>fs: gcsfs.core.GCSFileSystem) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Return list of all buckets in the file system.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_buckets(fs: gcsfs.GCSFileSystem) -&gt; List[str]:
    &#34;&#34;&#34;Return list of all buckets in the file system.&#34;&#34;&#34;
    if &#34;&#34; not in fs.dircache:
        items = []
        page = fs.call(&#34;GET&#34;, &#34;b/&#34;, project=fs.project, json_out=True)

        assert page[&#34;kind&#34;] == &#34;storage#buckets&#34;
        items.extend(page.get(&#34;items&#34;, []))
        next_page_token = page.get(&#34;nextPageToken&#34;, None)

        while next_page_token is not None:
            page = fs.call(
                &#34;GET&#34;,
                &#34;b/&#34;,
                project=fs.project,
                pageToken=next_page_token,
                json_out=True,
            )

            assert page[&#34;kind&#34;] == &#34;storage#buckets&#34;
            items.extend(page.get(&#34;items&#34;, []))
            next_page_token = page.get(&#34;nextPageToken&#34;, None)
        fs.dircache[&#34;&#34;] = [{&#34;name&#34;: i[&#34;name&#34;] + &#34;/&#34;, &#34;size&#34;: 0, &#34;type&#34;: &#34;directory&#34;} for i in items]
    return [b[&#34;name&#34;] for b in fs.dircache[&#34;&#34;]]</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.get_fs"><code class="name flex">
<span>def <span class="ident">get_fs</span></span>(<span>fs_kind: str, bucket: Optional[str] = None, token: Union[str, dict, None] = None, path: Optional[pathlib.Path] = None) ‑> Tuple[Union[gcsfs.core.GCSFileSystem, fsspec.implementations.local.LocalFileSystem], str, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the FileSystem object of either gcs or local (Default)</p>
<p>If GCS is asked and bucket is specified, will check that it exists and is accessible.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fs_kind</code></strong> :&ensp;<code>str</code></dt>
<dd>Returns GCSFileSystem if 'gcs_*', LocalFilsSystem if 'local'.</dd>
<dt><strong><code>bucket</code></strong> :&ensp;<code>str</code></dt>
<dd>bucket name for GCS</dd>
<dt><strong><code>token</code></strong> :&ensp;<code>Optional[Union[str, dict]]</code></dt>
<dd>credentials (default value = None)</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>Pathlib.Path</code></dt>
<dd>Only relevant if the method was called from TransparentPath.<strong>init</strong>() : will attempts to fetch the bucket
from the path if bucket is not given</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[Union[gcsfs.GCSFileSystem, LocalFileSystem], Union[None, str], Union[None, str], Union[None, str]]</code></dt>
<dd>The FileSystem object, the project if on GCS else None, and the bucket if on GCS.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fs(
    fs_kind: str,
    bucket: Union[str, None] = None,
    token: Optional[Union[str, dict]] = None,
    path: Union[Path, None] = None,
) -&gt; Tuple[Union[gcsfs.GCSFileSystem, LocalFileSystem], str, str]:
    &#34;&#34;&#34;Gets the FileSystem object of either gcs or local (Default)

    If GCS is asked and bucket is specified, will check that it exists and is accessible.

    Parameters
    ----------
    fs_kind: str
        Returns GCSFileSystem if &#39;gcs_*&#39;, LocalFilsSystem if &#39;local&#39;.
    bucket: str
        bucket name for GCS
    token: Optional[Union[str, dict]]
        credentials (default value = None)
    path: Pathlib.Path
        Only relevant if the method was called from TransparentPath.__init__() : will attempts to fetch the bucket
        from the path if bucket is not given

    Returns
    -------
    Tuple[Union[gcsfs.GCSFileSystem, LocalFileSystem], Union[None, str], Union[None, str], Union[None, str]]
        The FileSystem object, the project if on GCS else None, and the bucket if on GCS.
    &#34;&#34;&#34;

    if fs_kind is None:
        fs_kind = &#34;&#34;
    if fs_kind == &#34;&#34; and token is not None:
        fs_kind = &#34;gcs&#34;
    fs_name = None
    if fs_kind == &#34;local&#34;:
        bucket = None

    if path is not None and fs_kind != &#34;local&#34;:
        # Called from TransparentPath.__init__()
        if bucket is not None:
            fs_name = check_bucket(bucket)
        if bucket is None and len(path.parts) &gt; 0:
            bucket = path.parts[0]
            fs_name = check_bucket(bucket)
            if fs_name is None:
                bucket = None
        if bucket is None:
            bucket = TransparentPath.bucket
            fs_name = check_bucket(bucket)

        if fs_name is not None:
            return copy(TransparentPath.fss[fs_name]), fs_name, bucket

    if &#34;gcs&#34; in fs_kind or token is not None:

        # If bucket is specified, get the filesystem that contains it if it already exists. Else, create the filesystem.
        if bucket is not None:
            fs_name = check_bucket(bucket)
            if fs_name is not None:
                fs = copy(TransparentPath.fss[fs_name])
                return fs, fs_name, &#34;&#34;

        fs_name, project, token = extract_fs_name(token)
        if fs_name in TransparentPath.fss:
            pass
        elif token is None:
            fs = gcsfs.GCSFileSystem(project=project, asynchronous=False)
            TransparentPath.buckets_in_project[fs_name] = get_buckets(fs)
            TransparentPath.fss[fs_name] = fs
        else:
            fs = gcsfs.GCSFileSystem(project=project, asynchronous=False, token=token)
            TransparentPath.buckets_in_project[fs_name] = get_buckets(fs)
            TransparentPath.fss[fs_name] = fs

        ret_bucket = False
        if bucket is None and path is not None and len(path.parts) &gt; 0:
            bucket = path.parts[0]
            ret_bucket = True
        if bucket is not None:
            if not bucket.endswith(&#34;/&#34;):
                bucket += &#34;/&#34;
            if bucket not in TransparentPath.buckets_in_project[fs_name]:
                raise NotADirectoryError(f&#34;Bucket {bucket} does not exist in any loaded projects&#34;)

        fs = copy(TransparentPath.fss[fs_name])
        if ret_bucket:
            return fs, fs_name, bucket
        else:
            return fs, fs_name, &#34;&#34;
    else:
        if &#34;local&#34; not in TransparentPath.fss:
            TransparentPath.fss[&#34;local&#34;] = LocalFileSystem()
        return copy(TransparentPath.fss[&#34;local&#34;]), &#34;local&#34;, &#34;&#34;</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.get_index_and_date_from_kwargs"><code class="name flex">
<span>def <span class="ident">get_index_and_date_from_kwargs</span></span>(<span>**kwargs: dict) ‑> Tuple[int, bool, dict]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_index_and_date_from_kwargs(**kwargs: dict) -&gt; Tuple[int, bool, dict]:
    index_col = kwargs.get(&#34;index_col&#34;, None)
    parse_dates = kwargs.get(&#34;parse_dates&#34;, None)
    if index_col is not None:
        del kwargs[&#34;index_col&#34;]
    if parse_dates is not None:
        del kwargs[&#34;parse_dates&#34;]
    # noinspection PyTypeChecker
    return index_col, parse_dates, kwargs</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.myisinstance"><code class="name flex">
<span>def <span class="ident">myisinstance</span></span>(<span>obj1: Any, obj2) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Will return True when testing whether a TransparentPath is a str (required to use open(TransparentPath()))
and False when testing whether a pathlib.Path is a TransparentPath.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def myisinstance(obj1: Any, obj2) -&gt; bool:
    &#34;&#34;&#34;Will return True when testing whether a TransparentPath is a str (required to use open(TransparentPath()))
    and False when testing whether a pathlib.Path is a TransparentPath.&#34;&#34;&#34;

    if not (builtins_isinstance(obj2, list) or builtins_isinstance(obj2, set) or builtins_isinstance(obj2, tuple)):
        return mysmallisinstance(obj1, obj2)
    else:
        is_instance = False
        for _type in obj2:
            is_instance |= mysmallisinstance(obj1, _type)
        return is_instance</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.mysmallisinstance"><code class="name flex">
<span>def <span class="ident">mysmallisinstance</span></span>(<span>obj1: Any, obj2) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Will return True when testing whether a TransparentPath is a str (required to use open(TransparentPath()))
or a TransparentPath, and False in every other cases (even pathlib.Path).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mysmallisinstance(obj1: Any, obj2) -&gt; bool:
    &#34;&#34;&#34;Will return True when testing whether a TransparentPath is a str (required to use open(TransparentPath()))
    or a TransparentPath, and False in every other cases (even pathlib.Path).&#34;&#34;&#34;

    if type(obj1) == TransparentPath:
        if obj2 == TransparentPath or obj2 == str:
            return True
        else:
            return False

    if obj2 == TransparentPath:
        if type(obj1) == TransparentPath:
            return True
        else:
            return False

    return builtins_isinstance(obj1, obj2)</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.treat_remote_prefix"><code class="name flex">
<span>def <span class="ident">treat_remote_prefix</span></span>(<span>path: Union[pathlib.Path, <a title="transparentpath.gcsutils.transparentpath.TransparentPath" href="#transparentpath.gcsutils.transparentpath.TransparentPath">TransparentPath</a>, str], bucket: str) ‑> Tuple[str, str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def treat_remote_prefix(path: Union[Path, TransparentPath, str], bucket: str) -&gt; Tuple[str, str]:
    splitted = str(path).split(TransparentPath.remote_prefix)
    if len(splitted) == 0:
        if bucket is None and TransparentPath.bucket is None:
            raise ValueError(
                &#34;If using a path starting with &#39;gs://&#39;, you must include the bucket name in it unless it&#34;
                &#34;is specified with bucket= or if TransparentPath already has been set to use a specified bucket&#34;
                &#34;with set_global_fs&#34;
            )
        path = str(path).replace(TransparentPath.remote_prefix, &#34;&#34;, 1)

    else:
        bucket_from_path = splitted[1].split(&#34;/&#34;)[0]
        if bucket is not None:
            if bucket != bucket_from_path:
                raise ValueError(
                    f&#34;Bucket name {bucket_from_path} was found in your path name, but it does &#34;
                    f&#34;not match the bucket name you specified with bucket={bucket}&#34;
                )
        else:
            bucket = bucket_from_path

        path = str(path).replace(TransparentPath.remote_prefix, &#34;&#34;, 1)
        if path.startswith(bucket_from_path) or (len(path) &gt; 0 and path[1:].startswith(bucket_from_path)):
            path = path.replace(bucket_from_path, &#34;&#34;, 1)
        if path.startswith(&#34;/&#34;):
            path = path[1:]
    return path, bucket</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="transparentpath.gcsutils.transparentpath.TPCachingWarning"><code class="flex name class">
<span>class <span class="ident">TPCachingWarning</span></span>
<span>(</span><span>message: str = '')</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for warning categories.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TPCachingWarning(Warning):
    def __init__(self, message: str = &#34;&#34;):
        self.message = message
        super().__init__(self.message)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Warning</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TPMultipleExistenceError"><code class="flex name class">
<span>class <span class="ident">TPMultipleExistenceError</span></span>
<span>(</span><span>path, ls)</span>
</code></dt>
<dd>
<div class="desc"><p>Exception raised when a path's destination already contain more than
one element.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TPMultipleExistenceError(Exception):
    &#34;&#34;&#34;Exception raised when a path&#39;s destination already contain more than
    one element.
    &#34;&#34;&#34;

    def __init__(self, path, ls):
        self.path = path
        self.ls = ls
        self.message = (
            f&#34;Error in TransparentPath: Multiple objects exist at path {path}.\nHere is the output of ls in the &#34;
            f&#34;parent directory:\n {self.ls}&#34;
        )
        super().__init__(self.message)

    def __str__(self):
        return self.message</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath"><code class="flex name class">
<span>class <span class="ident">TransparentPath</span></span>
<span>(</span><span>path: Union[pathlib.Path, <a title="transparentpath.gcsutils.transparentpath.TransparentPath" href="#transparentpath.gcsutils.transparentpath.TransparentPath">TransparentPath</a>, str] = '.', collapse: bool = True, fs: Optional[str] = '', bucket: Optional[str] = None, token: Union[str, dict, None] = None, nocheck: Optional[bool] = None, notupdatecache: Optional[bool] = None, update_expire: Optional[int] = None, check_expire: Optional[int] = None, when_checked: Optional[dict] = None, when_updated: Optional[dict] = None, enable_caching: bool = False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A class that allows one to use a path in a local file system or a Google Cloud Storage (GCS) file system in the
same way one would use a <code>pathlib.Path</code> object. One can use many different GCP projects at once.</p>
<p>Create a path that points to GCS, and one that does not:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from transparentpath import Path
&gt;&gt;&gt; # Or : from transparentpath import TransparentPath
&gt;&gt;&gt; p = Path(&quot;gs://mybucket/some_path&quot;, token=&quot;some/cred/file.json&quot;)
&gt;&gt;&gt; p2 = p / &quot;foo&quot;  # Will point to gs://mybucket/some_path/foo
&gt;&gt;&gt; p3 = Path(&quot;bar&quot;)  # Will point to local path &quot;bar&quot;
</code></pre>
<p>Set all paths to point to GCS by default:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from transparentpath import Path
&gt;&gt;&gt; Path.set_global_fs(&quot;gcs&quot;, token=&quot;some/cred/file.json&quot;)
&gt;&gt;&gt; p = Path(&quot;mybucket&quot;) / &quot;some_path&quot; # Will point to gs://mybucket/some_path
&gt;&gt;&gt; p2 = p / &quot;foo&quot;  # Will point to gs://mybucket/some_path/foo
&gt;&gt;&gt; p3 = Path(&quot;bar&quot;, fs=&quot;local&quot;)  # Will point to local path &quot;bar&quot;
&gt;&gt;&gt; p4 = Path(&quot;other_bucket&quot;)  # Will point to gs://other_bucket (assuming other_bucket is a bucket)
&gt;&gt;&gt; p5 = Path(&quot;not_a_bucket&quot;)  # Will point to local path &quot;not_a_bucket&quot; (assuming it is indeed, not a bucket)
</code></pre>
<p>Set all paths to point to severral GCS projects by default:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from transparentpath import Path
&gt;&gt;&gt; Path.set_global_fs(&quot;gcs&quot;, token=&quot;some/cred/file.json&quot;)
&gt;&gt;&gt; Path.set_global_fs(&quot;gcs&quot;, token=&quot;some/other/cred/file.json&quot;)
&gt;&gt;&gt; p = Path(&quot;mybucket&quot;) / &quot;some_path&quot; # Will point to gs://mybucket/some_path
&gt;&gt;&gt; p2 = p / &quot;foo&quot;  # Will point to gs://mybucket/some_path/foo
&gt;&gt;&gt; p3 = Path(&quot;bar&quot;, fs=&quot;local&quot;)  # Will point to local path &quot;bar&quot;
&gt;&gt;&gt; p4 = Path(&quot;other_bucket&quot;)  # Will point to gs://other_bucket (assuming other_bucket is a bucket)
&gt;&gt;&gt; p5 = Path(&quot;not_a_bucket&quot;)  # Will point to local path &quot;not_a_bucket&quot; (assuming it is indeed, not a bucket)
</code></pre>
<p>Here, <em>mybucket</em> and <em>other_bucket</em> can be on two different projects, as long as at least one of the
credential files can access them.</p>
<p>Set all paths to point to GCS by default, and specify a default bucket:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from transparentpath import Path
&gt;&gt;&gt; Path.set_global_fs(&quot;gcs&quot;, bucket=&quot;mybucket&quot;, token=&quot;some/cred/file.json&quot;)
&gt;&gt;&gt; p = Path(&quot;some_path&quot;)  # Will point to gs://mybucket/some_path/
&gt;&gt;&gt; p2 = p / &quot;foo&quot;  # Will point to gs://mybucket/some_path/foo
&gt;&gt;&gt; p3 = Path(&quot;bar&quot;, fs=&quot;local&quot;)  # Will point to local path &quot;bar&quot;
&gt;&gt;&gt; p4 = Path(&quot;other_bucket&quot;)  # Will point to gs://mybucket/other_bucket
&gt;&gt;&gt; p5 = Path(&quot;not_a_bucket&quot;)  # Will point to gs://mybucket/not_a_bucket
</code></pre>
<p>The latest option is interesting if you have a code that should be able to run with paths being sometimes remote,
sometimes local. To do that, you can use the class attribute <code>nas_dir</code>. Then when a path is created, if it starts by
<em>nas_dir</em>'s path, <em>nas_dir</em>'s path is replaced by the bucket name. This is useful if, for instance, you have a
backup of a bucket locally at let's say <em>/my/local/backup</em>. Then you can do:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from transparentpath import Path
&gt;&gt;&gt; Path.nas_dir = &quot;/my/local/backup&quot;
&gt;&gt;&gt; Path.set_global_fs(&quot;gcs&quot;, bucket=&quot;mybucket&quot;, token=&quot;some/cred/file.json&quot;)
&gt;&gt;&gt; p = Path(&quot;some_path&quot;)  # Will point to gs://mybucket/some_path/
&gt;&gt;&gt; p3 = Path(&quot;/my/local/backup&quot;) / &quot;some_path&quot;  # Will ALSO point to gs://mybucket/some_path/
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; from transparentpath import Path
&gt;&gt;&gt; Path.nas_dir = &quot;/my/local/backup&quot;
&gt;&gt;&gt; # Path.set_global_fs(&quot;gcs&quot;, bucket=&quot;mybucket&quot;, token=&quot;some/cred/file.json&quot;)
&gt;&gt;&gt; p = Path(&quot;some_path&quot;)  # Will point to /my/local/backup/some_path/
&gt;&gt;&gt; p3 = Path(&quot;/my/local/backup&quot;) / &quot;some_path&quot;  # Will ALSO point to /my/local/backup/some_path/
</code></pre>
<p>In all the previous examples, the <em>token</em> argument can be ommited if the environment variable
<strong>GOOGLE_APPLICATION_CREDENTIALS</strong> is set and point to a <em>.json</em> credential file, or if your code runs on a GCP
machine (VM, cluster&hellip;) with access to GCS.</p>
<p>No matter whether you are using GCS or your local file system, here is a sample of what TransparentPath can do:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from transparentpath import Path
&gt;&gt;&gt; # Path.set_global_fs(&quot;gcs&quot;, bucket=&quot;bucket_name&quot;, project=&quot;project_name&quot;)
&gt;&gt;&gt; # The following lines will also work with the previous line uncommented
&gt;&gt;&gt;
&gt;&gt;&gt; # Reading a csv into a pandas' DataFrame and saving it as a parquet file
&gt;&gt;&gt; mypath = Path(&quot;foo&quot;) / &quot;bar.csv&quot;
&gt;&gt;&gt; df = mypath.read(index_col=0, parse_dates=True)
&gt;&gt;&gt; otherpath = mypath.with_suffix(&quot;.parquet&quot;)
&gt;&gt;&gt; otherpath.write(df)
&gt;&gt;&gt;
&gt;&gt;&gt; # Reading and writing a HDF5 file works on GCS and on local:
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; mypath = Path(&quot;foo&quot;) / &quot;bar.hdf5&quot;  # can be .h5 too
&gt;&gt;&gt; with mypath.read() as ifile:
&gt;&gt;&gt;     arr = np.array(ifile[&quot;store1&quot;])
&gt;&gt;&gt;
&gt;&gt;&gt; # Doing '..' from 'foo/bar.hdf5' will return 'foo'
&gt;&gt;&gt; # Then doing 'foo' + 'babar.hdf5' will return 'foo/babar.hdf5' ('+' and '/' are synonymes)
&gt;&gt;&gt; mypath.cd(&quot;..&quot;)  # Does not return a path but modifies inplace
&gt;&gt;&gt; with (mypath  + &quot;babar.hdf5&quot;).write(None) as ofile:
&gt;&gt;&gt;     # Note here that we must explicitely give 'None' to the 'write' method in order for it
&gt;&gt;&gt;     # to return the open HDF5 file. We could also give a dict of {arr: &quot;store1&quot;} to directly
&gt;&gt;&gt;     # write the file.
&gt;&gt;&gt;     ofile[&quot;store1&quot;] = arr
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; # Reading a text file. Can also use 'w', 'a', etc... also works with binaries.
&gt;&gt;&gt; mypath = Path(&quot;foo&quot;) / &quot;bar.txt&quot;
&gt;&gt;&gt; with open(mypath, &quot;r&quot;) as ifile:
&gt;&gt;&gt;     lines = ifile.readlines()
&gt;&gt;&gt;
&gt;&gt;&gt; # open is overriden to understand gs://
&gt;&gt;&gt; with open(&quot;gs://bucket/file.txt&quot;, &quot;r&quot;) as ifile:
&gt;&gt;&gt;     _ = ifile.readlines()
&gt;&gt;&gt;
&gt;&gt;&gt; mypath.is_file()
&gt;&gt;&gt; mypath.is_dir()
&gt;&gt;&gt; mypath.is_file()
&gt;&gt;&gt; files = mypath.parent.glob(&quot;*.csv&quot;)  # Returns a Iterator[TransparentPath], can be casted to list
</code></pre>
<p>As you can see from the previous example, all methods returning a path from a TransparentPath return a
TransparentPath.</p>
<p>TransparentPath supports writing and reading Dask dataframes from and to csv, excel, parquet and HDF5, both locally
and remotely. You need to have dask-dataframe and dask-distributed installed, which will be the case if you ran <code>pip
install transparentpath[dask]</code>. Writing Dask dataframes does not require any additionnal arguments to be
passed for the type will be checked before calling the appropriate writting method. Reading however requires you to
pass the <em>use_dask</em> argument to the <code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.read" href="#transparentpath.gcsutils.transparentpath.TransparentPath.read">TransparentPath.read()</a></code> method.
If the file to read is HDF5, you will also need to specify <em>set_names</em>, matching the argument <em>key</em> of Dask's
<code>read_hdf()</code> method.</p>
<p>Note that if reading a remote HDF5, the file will be downloaded in your local tmp, then read. If not using Dask, the
file is deleted after being read. But since Dask uses delayed processes, deleting the file might occure before the
file is actually read, so the file is kept. Up to you to empty your <em>/tmp</em> directory if it is not done automatically
by your system.</p>
<p>All instances of TransparentPath are absolute, even if created with relative paths.</p>
<p>TransparentPaths are seen as instances of str:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from transparentpath import Path
&gt;&gt;&gt; path = Path()
&gt;&gt;&gt; isinstance(path, str)  # returns True
</code></pre>
<p>This is required to allow</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from transparentpath import Path
&gt;&gt;&gt; path = Path()
&gt;&gt;&gt; # noinspection PyTypeChecker
&gt;&gt;&gt; with open(path, &quot;w/r/a/b...&quot;) as ifile:
&gt;&gt;&gt; ...
to work. If you want to check whether path is actually a TransparentPath and nothing else, use
&gt;&gt;&gt; from transparentpath import Path
&gt;&gt;&gt; path = Path()
&gt;&gt;&gt; assert type(path) == Path
&gt;&gt;&gt; assert issubclass(path.__class__, Path)
instead.
</code></pre>
<p>Any method or attribute valid in <code>fsspec.implementations.local.LocalFileSystem</code>, <code>gcs.GCSFileSystem</code>, <code>pathlib.Path</code>
or <code>str</code> can be used on a TransparentPath object.</p>
<p><strong>Warnings about GCS behaviour</strong>
if you use GCS:</p>
<ol>
<li>
<p>Remember that directories are not a thing on GCS.</p>
</li>
<li>
<p>You do not need the parent directories of a file on GCS to create the file : they will be created if they do
not exist (that is not true localy however).</p>
</li>
<li>
<p>If you delete a file that was alone in its parent directories, those directories disapear.</p>
</li>
<li>
<p>If a file exists at the same path than a directory, then TransparentPath is not able to know which one is the
file and which one is the directory, and will raise a
<code><a title="transparentpath.gcsutils.transparentpath.TPMultipleExistenceError" href="#transparentpath.gcsutils.transparentpath.TPMultipleExistenceError">TPMultipleExistenceError</a></code> upon object creation. This
check for multiplicity is done at almost every method in case an exterior source created a duplicate of the
file/directory. This case can't happen locally. However, it can happen on remote if the cache is not updated
frequently. Doing this check can significantly increase computation time (if using glob on a directory
containing a lot of files for example). You can deactivate it either globally (TransparentPath._do_check =
False and TransparentPath._do_update_cache = False), for a specific path (pass nockeck=True at path
creation), or for glob and ls by passing fast=True as additional argument.</p>
</li>
</ol>
<p>TransparentPath on GCS is slow because of the verification for multiple existance and the cache updating.
However one can tweak those a bit. As mentionned earlier, cache updating and multiple existence check can be
deactivated for all paths by doing</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from transparentpath import TransparentPath
&gt;&gt;&gt; TransparentPath._do_update_cache = False
&gt;&gt;&gt; TransparentPath._do_check = False
</code></pre>
<p>They can also be deactivated for one path only by doing</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = TransparentPath(&quot;somepath&quot;, nocheck=True, notupdatecache=True)
</code></pre>
<p>It is also possible to specify when to do those check : at path creation, path usage (read, write, exists&hellip;) or
both. Here to it can be set on all paths or only some :</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; TransparentPath._when_checked = {&quot;created&quot;: True, &quot;used&quot;: False}  # Default value
&gt;&gt;&gt; TransparentPath._when_updated = {&quot;created&quot;: True, &quot;used&quot;: False}  # Default value
&gt;&gt;&gt; p = TransparentPath(
&gt;&gt;&gt;   &quot;somepath&quot;, when_checked={&quot;created&quot;: False, &quot;used&quot;: False}, notupdatecache={&quot;created&quot;: False, &quot;used&quot;: False}
&gt;&gt;&gt; )
</code></pre>
<p>There is also an expiration time in seconds for check and update : the operation is not done if it was done not a
long time ago. Those expiration times are of 1 second by default and can be changed through :</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; TransparentPath._check_expire = 10
&gt;&gt;&gt; TransparentPath._update_expire = 10
&gt;&gt;&gt; p = TransparentPath(&quot;somepath&quot;, check_expire=0, update_expire=0)
</code></pre>
<pre><code>

&lt;code&gt;&lt;a title=&quot;transparentpath.gcsutils.transparentpath.TransparentPath.glob&quot; href=&quot;#transparentpath.gcsutils.transparentpath.TransparentPath.glob&quot;&gt;TransparentPath.glob()&lt;/a&gt;&lt;/code&gt; and
&lt;code&gt;&lt;a title=&quot;transparentpath.gcsutils.transparentpath.TransparentPath.ls&quot; href=&quot;#transparentpath.gcsutils.transparentpath.TransparentPath.ls&quot;&gt;TransparentPath.ls()&lt;/a&gt;&lt;/code&gt; have their own way to be accelerated :
```python-repl
&gt;&gt;&gt; p.glob(&quot;/*&quot;, fast=True)
&gt;&gt;&gt; p.ls(&quot;&quot;, fast=True)
Basically, *fast=True* means &quot;do not check and do not update the cache&quot; for all the items found by the method.
</code></pre>
<p>Builtin <code>open</code> is overloaded by TransparentPath to support giving a TransparentPath to it. If a method in a package
you did not create uses <code>open</code> in a <em>with</em> statement, everything should work out of the box with a TransparentPath.</p>
<p>However, if it uses the <strong>output</strong> of <code>open</code>, you will have to create a class to
override this method and anything using its ouput. Indeed, <code>open</code> returns a file descriptor, not an IO, and I did
not find a way to access file descriptors on gcs. For example, in the FileLock package, the <code>acquire</code> method calls
the <code>_acquire</code> method which calls <code>os.open</code>, so I had to do that:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from filelock import FileLock
&gt;&gt;&gt; from transparentpath import Path
&gt;&gt;&gt;
&gt;&gt;&gt; class MyFileLock(FileLock):
&gt;&gt;&gt;     def _acquire(self):
&gt;&gt;&gt;         tmp_lock_file = self._lock_file
&gt;&gt;&gt;         if not type(tmp_lock_file) == Path:
&gt;&gt;&gt;             tmp_lock_file = Path(tmp_lock_file)
&gt;&gt;&gt;         try:
&gt;&gt;&gt;             fd = tmp_lock_file.open(&quot;x&quot;)
&gt;&gt;&gt;         except (IOError, OSError, FileExistsError):
&gt;&gt;&gt;             pass
&gt;&gt;&gt;         else:
&gt;&gt;&gt;             self._lock_file_fd = fd
&gt;&gt;&gt;         return None
</code></pre>
<p>The original method was:</p>
<blockquote>
<blockquote>
<blockquote></blockquote>
</blockquote>
</blockquote>
<pre><code class="language-python-repl">&gt;&gt;&gt; import os
&gt;&gt;&gt; ...
&gt;&gt;&gt; def _acquire(self):
&gt;&gt;&gt;     open_mode = os.O_WRONLY | os.O_CREAT | os.O_EXCL | os.O_TRUNC
&gt;&gt;&gt;     try:
&gt;&gt;&gt;         fd = os.open(self._lock_file, open_mode)
&gt;&gt;&gt;     except (IOError, OSError):
&gt;&gt;&gt;         pass
&gt;&gt;&gt;     else:
&gt;&gt;&gt;         self._lock_file_fd = fd
&gt;&gt;&gt;     return None
&gt;&gt;&gt; ...
</code></pre>
<p>I tried to implement a working version of any method valid in pathlib.Path or in file systems, but futur changes
in any of those will not be taken into account quickly. You can report missing supports by opening an issue.</p>
<p>Creator of the TranparentPath object</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>Union[pathlib.Path, <a title="transparentpath.gcsutils.transparentpath.TransparentPath" href="#transparentpath.gcsutils.transparentpath.TransparentPath">TransparentPath</a>, str]</code></dt>
<dd>The path of the object (Default value = '.')</dd>
<dt><strong><code>collapse</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, will collapse any double dots ('..') in path. (Default value = True)</dd>
<dt><strong><code>fs</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The file system to use, 'local' or 'gcs'. If None, uses the default one set by
<code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.set_global_fs" href="#transparentpath.gcsutils.transparentpath.TransparentPath.set_global_fs">TransparentPath.set_global_fs()</a></code> if any, or 'local' (Default = None)</dd>
<dt><strong><code>bucket</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The bucket name if using GCS and if path is not 'gs://bucket/&hellip;'</dd>
<dt><strong><code>token</code></strong> :&ensp;<code>Optional[Union[dict, str]]</code></dt>
<dd>The path to google application credentials json file to use, if envvar GOOGLE_APPLICATION_CREDENTIALS
is not set and the code is not running on a GCP machine.</dd>
<dt><strong><code>nocheck</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, will not call check_multiplicity (quicker but less secure). Takes the value of
not Transparentpath._do_check if None (Default value = None)</dd>
<dt><strong><code>notupdatecache</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, will not call _invalidate_cache when doing operations on this path (quicker but less secure).
Takes the value of not Transparentpath._do_update_cache if None (Default value = None)</dd>
<dt><strong><code>update_expire</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Time in second after which the cache is considered obsolete and must be updated. Takes the value of
Transparentpath._update_expire if None (Default value = None)</dd>
<dt><strong><code>check_expire</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Time in second after which the check for multiple existence is considered obsolete and must be updated.
Takes the value of Transparentpath._check_expire if None (Default value = None)</dd>
<dt><strong><code>when_checked</code></strong> :&ensp;<code>Optional[dict]</code></dt>
<dd>Dict of the form {"used: True, "created": True}, that indicates when to check multiplicity of the path.
Takes the value of Transparentpath._when_checked if None (Default value = None)</dd>
<dt><strong><code>when_updated</code></strong> :&ensp;<code>Optional[dict]</code></dt>
<dd>Same as when_checked but for cache update.</dd>
<dt><strong><code>enable_caching</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, will enable file caching, meaning file content read from a transparentpath will be saved in tmp
for quicker access later in the code. Default is False.</dd>
</dl>
<p>kwargs:
Any optional kwargs valid for <code>pathlib.Path</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TransparentPath:
    def __fspath__(self) -&gt; str:
        &#34;&#34;&#34;Implemented later&#34;&#34;&#34;
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>os.PathLike</li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.LOCAL_SEP"><code class="name">var <span class="ident">LOCAL_SEP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.bucket"><code class="name">var <span class="ident">bucket</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.buckets_in_project"><code class="name">var <span class="ident">buckets_in_project</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.cached_data_dict"><code class="name">var <span class="ident">cached_data_dict</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.caching"><code class="name">var <span class="ident">caching</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.caching_max_memory"><code class="name">var <span class="ident">caching_max_memory</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.cli"><code class="name">var <span class="ident">cli</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.cwd"><code class="name">var <span class="ident">cwd</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.fs_kind"><code class="name">var <span class="ident">fs_kind</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.fss"><code class="name">var <span class="ident">fss</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.method_path_concat"><code class="name">var <span class="ident">method_path_concat</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.method_without_self_path"><code class="name">var <span class="ident">method_without_self_path</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.nas_dir"><code class="name">var <span class="ident">nas_dir</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.remote_prefix"><code class="name">var <span class="ident">remote_prefix</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.tokens"><code class="name">var <span class="ident">tokens</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.translations"><code class="name">var <span class="ident">translations</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.unset"><code class="name">var <span class="ident">unset</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.used_memory"><code class="name">var <span class="ident">used_memory</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.get_state"><code class="name flex">
<span>def <span class="ident">get_state</span></span>(<span>) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the state of the TransparentPath class in a dictionnary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_state(cls) -&gt; dict:
    &#34;&#34;&#34;Returns the state of the TransparentPath class in a dictionnary&#34;&#34;&#34;
    state = {
        &#34;remote_prefix&#34;: cls.remote_prefix,
        &#34;fss&#34;: cls.fss,
        &#34;buckets_in_project&#34;: cls.buckets_in_project,
        &#34;fs_kind&#34;: cls.fs_kind,
        &#34;bucket&#34;: cls.bucket,
        &#34;nas_dir&#34;: cls.nas_dir,
        &#34;unset&#34;: cls.unset,
        &#34;cwd&#34;: cls.cwd,
        &#34;tokens&#34;: cls.tokens,
        &#34;_do_update_cache&#34;: cls._do_update_cache,
        &#34;_do_check&#34;: cls._do_check,
        &#34;_check_expire&#34;: cls._check_expire,
        &#34;_update_expire&#34;: cls._update_expire,
        &#34;_when_checked&#34;: cls._when_checked,
        &#34;_when_updated&#34;: cls._when_updated,
        &#34;LOCAL_SEP&#34;: cls.LOCAL_SEP,
        &#34;cached_data_dict: &#34;: cls.cached_data_dict,
        &#34;used_memory: &#34;: cls.used_memory,
        &#34;caching: &#34;: cls.caching,
        &#34;caching_max_memory: &#34;: cls.caching_max_memory,
    }
    return state</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.reinit"><code class="name flex">
<span>def <span class="ident">reinit</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Reinit all class attributes to their default values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def reinit(cls):
    &#34;&#34;&#34;Reinit all class attributes to their default values&#34;&#34;&#34;
    cls.remote_prefix = &#34;gs://&#34;
    cls.fss = {}
    cls.buckets_in_project = {}
    cls.fs_kind = None
    cls.bucket = None
    cls.nas_dir = None
    cls.unset = True
    cls.cwd = os.getcwd()
    cls.tokens = {}
    cls._do_update_cache = True
    cls._do_check = True
    cls._check_expire = 1
    cls._update_expire = 1
    cls._when_checked = {&#34;used&#34;: False, &#34;created&#34;: True}
    cls._when_updated = {&#34;used&#34;: False, &#34;created&#34;: True}
    cls.LOCAL_SEP = os.path.sep
    cls.cached_data_dict = collections.OrderedDict()
    cls.used_memory = 0
    cls.caching = &#34;None&#34;
    cls.caching_max_memory = 100</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.set_global_fs"><code class="name flex">
<span>def <span class="ident">set_global_fs</span></span>(<span>fs: str, bucket: Optional[str] = None, nas_dir: Union[<a title="transparentpath.gcsutils.transparentpath.TransparentPath" href="#transparentpath.gcsutils.transparentpath.TransparentPath">TransparentPath</a>, pathlib.Path, str, None] = None, token: Union[str, dict, None] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>To call before creating any instance to set the file system.</p>
<p>If not called, default file system is local. If the first parameter is 'local', the file system is local. If
the first parameter is 'gcs', file system is GCS.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fs</code></strong> :&ensp;<code>str</code></dt>
<dd>'gcs' will use GCSFileSystem, 'local' will use LocalFileSystem</dd>
<dt><strong><code>bucket</code></strong> :&ensp;<code>str</code></dt>
<dd>The bucket name, only valid if using gcs (Default value =
None)</dd>
<dt><strong><code>nas_dir</code></strong> :&ensp;<code>Union[<a title="transparentpath.gcsutils.transparentpath.TransparentPath" href="#transparentpath.gcsutils.transparentpath.TransparentPath">TransparentPath</a>, Path, str]</code></dt>
<dd>If specified, TransparentPath will delete any occurence of 'nas_dir' at the beginning of created paths if fs
is gcs (Default value = None).</dd>
<dt><strong><code>token</code></strong> :&ensp;<code>Optional[Union[dict, str]]</code></dt>
<dd>credentials (default value = None). If not specified, will use envvar GOOGLE_APPLICATION_CREDENTIALS. If not
specified either, will try to log with default account, which will work is using a machine on GCP
(VM, cluster&hellip;)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def set_global_fs(
    cls,
    fs: str,
    bucket: Union[str, None] = None,
    nas_dir: Optional[Union[TransparentPath, Path, str]] = None,
    token: Optional[Union[dict, str]] = None,
) -&gt; None:
    &#34;&#34;&#34;To call before creating any instance to set the file system.

    If not called, default file system is local. If the first parameter is &#39;local&#39;, the file system is local. If
    the first parameter is &#39;gcs&#39;, file system is GCS.

    Parameters
    ----------
    fs: str
        &#39;gcs&#39; will use GCSFileSystem, &#39;local&#39; will use LocalFileSystem
    bucket: str
        The bucket name, only valid if using gcs (Default value =  None)
    nas_dir: Union[TransparentPath, Path, str]
        If specified, TransparentPath will delete any occurence of &#39;nas_dir&#39; at the beginning of created paths if fs
        is gcs (Default value = None).
    token: Optional[Union[dict, str]]
        credentials (default value = None). If not specified, will use envvar GOOGLE_APPLICATION_CREDENTIALS. If not
        specified either, will try to log with default account, which will work is using a machine on GCP
        (VM, cluster...)

    Returns
    -------
    None
    &#34;&#34;&#34;
    if &#34;gcs&#34; not in fs and fs != &#34;local&#34;:
        raise ValueError(f&#34;Unknown value {fs} for parameter &#39;fs&#39;&#34;)

    cls.fs_kind = fs
    cls.bucket = bucket

    TransparentPath._set_nas_dir(cls, nas_dir)
    get_fs(cls.fs_kind, cls.bucket, token)
    TransparentPath.unset = False</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.show_state"><code class="name flex">
<span>def <span class="ident">show_state</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints the state of the TransparentPath class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def show_state(cls):
    &#34;&#34;&#34;Prints the state of the TransparentPath class&#34;&#34;&#34;
    print(&#34;remote_prefix: &#34;, cls.remote_prefix)
    print(&#34;fss: &#34;, cls.fss)
    print(&#34;buckets_in_project: &#34;, cls.buckets_in_project)
    print(&#34;fs_kind: &#34;, cls.fs_kind)
    print(&#34;bucket: &#34;, cls.bucket)
    print(&#34;nas_dir: &#34;, cls.nas_dir)
    print(&#34;unset: &#34;, cls.unset)
    print(&#34;cwd: &#34;, cls.cwd)
    print(&#34;tokens: &#34;, cls.tokens)
    print(&#34;_do_update_cache: &#34;, cls._do_update_cache)
    print(&#34;_do_check: &#34;, cls._do_check)
    print(&#34;_check_expire: &#34;, cls._check_expire)
    print(&#34;_update_expire: &#34;, cls._update_expire)
    print(&#34;_when_updated: &#34;, cls._when_updated)
    print(&#34;LOCAL_SEP: &#34;, cls.LOCAL_SEP)
    print(&#34;cached_data_dict: &#34;, cls.cached_data_dict)
    print(&#34;used_memory: &#34;, cls.used_memory)
    print(&#34;caching: &#34;, cls.caching)
    print(&#34;caching_max_memory: &#34;, cls.caching_max_memory)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.absolute"><code class="name">var <span class="ident">absolute</span> : <a title="transparentpath.gcsutils.transparentpath.TransparentPath" href="#transparentpath.gcsutils.transparentpath.TransparentPath">TransparentPath</a></code></dt>
<dd>
<div class="desc"><p>Returns self, since all TransparentPaths are absolute</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath" href="#transparentpath.gcsutils.transparentpath.TransparentPath">TransparentPath</a></code></dt>
<dd>self</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def absolute(self) -&gt; TransparentPath:
    &#34;&#34;&#34;Returns self, since all TransparentPaths are absolute

    Returns
    -------
    TransparentPath
        self

    &#34;&#34;&#34;
    return self</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.buckets"><code class="name">var <span class="ident">buckets</span> : List[str]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def buckets(self) -&gt; List[str]:
    if self.fs_kind == &#34;local&#34;:
        return []
    return get_buckets(self.fs)</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.download"><code class="name">var <span class="ident">download</span> : Optional[str]</code></dt>
<dd>
<div class="desc"><p>Returns a clickable link to download the file from GCS.</p>
<p>Returns None if the path does not correspond to an existing file on GCS.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def download(self) -&gt; Union[None, str]:
    &#34;&#34;&#34;Returns a clickable link to download the file from GCS.

    Returns None if the path does not correspond to an existing file on GCS.
    &#34;&#34;&#34;
    if self.fs_kind.startswith(&#34;gcs&#34;) and self.is_file():
        obj = str(self).replace(TransparentPath.remote_prefix, &#34;&#34;).replace(&#34; &#34;, &#34;%20&#34;)
        return f&#34;https://storage.cloud.google.com/{obj}&#34;
    return None</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.path"><code class="name">var <span class="ident">path</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def path(self):
    return self.__path</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.url"><code class="name">var <span class="ident">url</span> : Optional[str]</code></dt>
<dd>
<div class="desc"><p>Returns a clickable link to open the path in GCS</p>
<p>Returns None if the path does not correspond to an existing file or directory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def url(self) -&gt; Union[None, str]:
    &#34;&#34;&#34;Returns a clickable link to open the path in GCS

    Returns None if the path does not correspond to an existing file or directory.
    &#34;&#34;&#34;
    obj = str(self).replace(TransparentPath.remote_prefix, &#34;&#34;).replace(&#34; &#34;, &#34;%20&#34;)
    if self.fs_kind.startswith(&#34;gcs&#34;):
        project = self.fs.project
        if self.is_file():
            prefix = &#34;https://console.cloud.google.com/storage/browser/_details/&#34;
            postfix = f&#34;;tab=live_object?project={project}&#34;
        elif self.is_dir():
            prefix = &#34;https://console.cloud.google.com/storage/browser/&#34;
            postfix = f&#34;;tab=objects?project={project}&#34;
        else:
            return None
    else:
        if not self.exists():
            return None
        return f&#34;file://{obj}&#34;
    return f&#34;{prefix}{obj}{postfix}&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, other: str) ‑> <a title="transparentpath.gcsutils.transparentpath.TransparentPath" href="#transparentpath.gcsutils.transparentpath.TransparentPath">TransparentPath</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, other: str) -&gt; TransparentPath:
    return TransparentPath(
        str(self) + other,
        fs=self.fs_kind,
        bucket=self.bucket,
        notupdatecache=self.notupdatecache,
        nocheck=self.nocheck,
        when_checked=self.when_checked,
        when_updated=self.when_updated,
        update_expire=self.update_expire,
        check_expire=self.check_expire,
    )</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.caching_ram"><code class="name flex">
<span>def <span class="ident">caching_ram</span></span>(<span>self, data, args, kwargs) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>caching for ram</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def caching_ram(self, data, args, kwargs) -&gt; None:
    &#34;&#34;&#34;
    caching for ram
    &#34;&#34;&#34;
    filesize = sys.getsizeof(data)
    if filesize &gt; TransparentPath.caching_max_memory * 1000000:
        warnings.warn(
            f&#34;You are trying to add in cache a file of {filesize / 1000000} MB, but the max memory &#34;
            f&#34;for caching is {TransparentPath.caching_max_memory} MB\nCaching canceled&#34;,
            TPCachingWarning,
        )
    else:
        while TransparentPath.used_memory + filesize &gt; TransparentPath.caching_max_memory * 1000000:
            # Drop oldest file
            byename, byefile = TransparentPath.cached_data_dict.popitem(last=False)
            TransparentPath.used_memory -= sys.getsizeof(byefile)
            warnings.warn(
                f&#34;You have exceeded the max memory for caching of {TransparentPath.caching_max_memory} MB&#34;
                f&#34;(old files {TransparentPath.used_memory / 1000000} MB, new file {filesize / 1000000})&#34;
                f&#34;removing from cach : {byename}&#34;,
                TPCachingWarning,
            )
        # Adding file to dict and filesize to total used memory
        TransparentPath.used_memory += filesize
        TransparentPath.cached_data_dict[self.__hash__()] = {&#34;data&#34;: data, &#34;args&#34;: args, &#34;kwargs&#34;: kwargs}</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.caching_saver"><code class="name flex">
<span>def <span class="ident">caching_saver</span></span>(<span>self, data, args, kwargs) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Save fetched data from read in tmp file or dict,
if total of cach does not exceed caching_max_memory else remove oldest data</p>
<p>To use ram caching set self.caching to "ram", to use tmp file caching set self.caching to "tmpfile"</p>
<p>To disable caching, set self.caching to something else or self.enable_caching to False</p>
<p>TransparentPath.caching_max_memory is in MB</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def caching_saver(self, data, args, kwargs) -&gt; None:
    &#34;&#34;&#34;
    Save fetched data from read in tmp file or dict,
     if total of cach does not exceed caching_max_memory else remove oldest data

    To use ram caching set self.caching to &#34;ram&#34;, to use tmp file caching set self.caching to &#34;tmpfile&#34;

    To disable caching, set self.caching to something else or self.enable_caching to False

    TransparentPath.caching_max_memory is in MB
    &#34;&#34;&#34;
    if self.enable_caching:
        if self.caching == &#34;ram&#34;:
            self.caching_ram(data, args, kwargs)

        elif self.caching == &#34;tmpfile&#34; and self.fs_kind != &#34;local&#34;:
            self.caching_tmpfile(args, kwargs)</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.caching_tmpfile"><code class="name flex">
<span>def <span class="ident">caching_tmpfile</span></span>(<span>self, args, kwargs) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>caching for tmpfile</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def caching_tmpfile(self, args, kwargs) -&gt; None:
    &#34;&#34;&#34;
    caching for tmpfile
    &#34;&#34;&#34;
    temp_file = tempfile.NamedTemporaryFile(delete=True, suffix=self.suffix)
    self.get(temp_file.name)
    # noinspection PyUnresolvedReferences
    tempfilesize = temp_file.file.tell()
    if tempfilesize &gt; TransparentPath.caching_max_memory * 1000000:
        warnings.warn(
            f&#34;You are trying to add in cache a file of {tempfilesize / 1000000} MB, but the max memory &#34;
            f&#34;for caching is {TransparentPath.caching_max_memory} MB\nCaching canceled&#34;,
            TPCachingWarning,
        )
    else:
        while TransparentPath.used_memory + tempfilesize &gt; TransparentPath.caching_max_memory * 1000000:
            byename, byefile = TransparentPath.cached_data_dict.popitem(last=False)
            byefile[&#34;file&#34;].close()
            TransparentPath.used_memory -= byefile[&#34;memory&#34;]
            warnings.warn(
                f&#34;You have exceeded the max memory for caching of {TransparentPath.caching_max_memory} MB&#34;
                f&#34;(old files {TransparentPath.used_memory / 1000000} MB, new file {tempfilesize / 1000000})&#34;
                f&#34;removing from cach : {byename}&#34;,
                TPCachingWarning,
            )
            del byefile
        TransparentPath.used_memory += tempfilesize
        TransparentPath.cached_data_dict[self.__hash__()] = {
            &#34;file&#34;: temp_file,
            &#34;memory&#34;: tempfilesize,
            &#34;args&#34;: args,
            &#34;kwargs&#34;: kwargs,
        }</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.cd"><code class="name flex">
<span>def <span class="ident">cd</span></span>(<span>self, path: Optional[str] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>cd-like command. Works inplace</p>
<p>Will collapse double-dots ('..'), so not compatible with symlinks. If path is absolute (starts with '/' or
bucket name or is empty), will return a path starting from root directory if FileSystem is local, from bucket
if it is GCS. If passing None or "" , will have the same effect than "/" on GCS, will return the current
working directory on local. If passing ".", will return a path at the location of self. Will raise an error
if trying to access a path before root or bucket.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to cd to. Absolute, or relative to self.
(Default value = None)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>None</code></strong> :&ensp;<code>works inplace</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cd(self, path: Optional[str] = None) -&gt; None:
    &#34;&#34;&#34;cd-like command. Works inplace

    Will collapse double-dots (&#39;..&#39;), so not compatible with symlinks. If path is absolute (starts with &#39;/&#39; or
    bucket name or is empty), will return a path starting from root directory if FileSystem is local, from bucket
    if it is GCS. If passing None or &#34;&#34; , will have the same effect than &#34;/&#34; on GCS, will return the current
    working directory on local. If passing &#34;.&#34;, will return a path at the location of self. Will raise an error
    if trying to access a path before root or bucket.


    Parameters
    ----------
    path: str
        The path to cd to. Absolute, or relative to self.
        (Default value = None)


    Returns
    -------
    None: works inplace

    &#34;&#34;&#34;

    # Will collapse any &#39;..&#39;

    if not isinstance(path, str) or isinstance(path, TransparentPath):
        raise TypeError(&#34;Can only pass a string to TransparentPath&#39;s cd method&#34;)

    path = path.replace(TransparentPath.remote_prefix, &#34;&#34;, 1)

    if &#34;gcs&#34; in self.fs_kind and str(path) == self.bucket or path == &#34;&#34; or str(path) == &#34;/&#34;:
        self.__path = Path(self.bucket)
        return

    # If asked to cd to home, return path script calling directory
    if path == &#34;&#34; or path is None:
        self.__path = Path()
        return

    # noinspection PyUnresolvedReferences
    self.__path = self.__path / path

    if self.fs_kind == &#34;local&#34;:
        # If asked for an absolute path
        if path.startswith(&#34;/&#34;):
            self.__path = Path(path)
            return
        # noinspection PyUnresolvedReferences
        if len(self.__path.parts) == 0:
            return
        # noinspection PyUnresolvedReferences
        if self.__path.parts[0] == &#34;..&#34;:
            raise ValueError(&#34;The first part of a path can not be &#39;..&#39;&#34;)
    else:
        # If asked for an absolute path
        if path.startswith(&#34;/&#34;):
            self.__path = Path(self.bucket) / path[1:]
            return
        # noinspection PyUnresolvedReferences
        if self.__path == 1:  # On gcs, first part is bucket
            return
        # noinspection PyUnresolvedReferences
        if self.__path.parts[1] == &#34;..&#34;:
            raise ValueError(&#34;Trying to access a path before bucket&#34;)

    # noinspection PyUnresolvedReferences
    self.__path = collapse_ddots(self.__path)</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.change_suffix"><code class="name flex">
<span>def <span class="ident">change_suffix</span></span>(<span>self, suffix: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_suffix(self, suffix: str) -&gt; None:
    if not suffix.startswith(&#34;.&#34;):
        suffix = f&#34;.{suffix}&#34;

    self.path = self.path.with_suffix(suffix)
    if self.when_checked[&#34;created&#34;] and not self.nocheck:
        self._check_multiplicity()
    elif self.when_updated[&#34;created&#34;] and not self.notupdatecache:  # Else, because called by check_multiplicity
        self._update_cache()</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.cp"><code class="name flex">
<span>def <span class="ident">cp</span></span>(<span>self, other: Union[str, pathlib.Path, <a title="transparentpath.gcsutils.transparentpath.TransparentPath" href="#transparentpath.gcsutils.transparentpath.TransparentPath">TransparentPath</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>Used to copy a file or a directory on the same filesystem.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cp(self, other: Union[str, Path, TransparentPath]):
    &#34;&#34;&#34;Used to copy a file or a directory on the same filesystem.&#34;&#34;&#34;

    # noinspection PyProtectedMember
    if not self.exist():
        raise FileNotFoundError(f&#34;No such file or directory: {self}&#34;)

    if not type(other) == TransparentPath:
        other = TransparentPath(
            other,
            fs=self.fs_kind,
            bucket=self.bucket,
            notupdatecache=self.notupdatecache,
            nocheck=self.nocheck,
            when_checked=self.when_checked,
            when_updated=self.when_updated,
            update_expire=self.update_expire,
            check_expire=self.check_expire,
            token=self.token,
        )
    if other.fs_kind != self.fs_kind:
        if self.fs_kind == &#34;local&#34;:
            self.put(other)
        else:
            self.get(other)
        return

    # Do not use filesystem&#39;s copy if self is not a file, for it was coded by apes and is not able to use recursive
    # properly

    if self.is_file():
        self.fs.cp(self.__fspath__(), other)
        return

    if self.isdir() and self.info()[&#34;size&#34;] == 0:
        other.mkdir()
        return

    for stuff in list(self.glob(&#34;**/*&#34;, fast=True)):
        # noinspection PyUnresolvedReferences
        if not stuff.is_file():
            continue
        # noinspection PyUnresolvedReferences
        relative = stuff.split(f&#34;/{self.name}/&#34;)[-1]
        newpath = other / relative
        newpath.parent.mkdir(recursive=True)
        self.fs.cp(stuff.__fspath__(), newpath)</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.exist"><code class="name flex">
<span>def <span class="ident">exist</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>To prevent typo of 'exist()' without an -s</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exist(self) -&gt; bool:
    &#34;&#34;&#34;To prevent typo of &#39;exist()&#39; without an -s&#34;&#34;&#34;
    return self.exists()</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.exists"><code class="name flex">
<span>def <span class="ident">exists</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exists(self) -&gt; bool:
    if str(self.path) == &#34;/&#34; and self.fs_kind == &#34;local&#34;:
        return True
    elif self.path == &#34;gs://&#34; and self.fs_kind == &#34;gcs&#34;:
        return True
    updated = False
    if self.when_checked[&#34;used&#34;] and not self.nocheck:
        self._check_multiplicity()
        updated = True
    elif self.when_updated[&#34;used&#34;] and not self.notupdatecache:
        self._update_cache()
        updated = True
    if not self.fs.exists(self.__fspath__()):
        if not updated:
            self._update_cache()
            return self.fs.exists(self.__fspath__())
        else:
            return False
    return True</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, loc: Union[str, pathlib.Path, <a title="transparentpath.gcsutils.transparentpath.TransparentPath" href="#transparentpath.gcsutils.transparentpath.TransparentPath">TransparentPath</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>used to get a remote file to local. Does not remove the remote file.</p>
<p>self must be a remote TransparentPath. If loc is a TransparentPath, it must be local. If it is a pathlib.Path or
a str, it will be casted into a local TransparentPath.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, loc: Union[str, Path, TransparentPath]):
    &#34;&#34;&#34;used to get a remote file to local. Does not remove the remote file.

    self must be a remote TransparentPath. If loc is a TransparentPath, it must be local. If it is a pathlib.Path or
    a str, it will be casted into a local TransparentPath. &#34;&#34;&#34;

    def recursive(source, destination):
        if not source.exists():
            raise FileNotFoundError(f&#34;Element {source} does not exist&#34;)
        if source.isfile():
            source.get(destination)
        elif source.isdir():
            for element in source.glob(&#34;*&#34;, fast=True):
                recursive(element, destination / element.name)
        else:
            raise ValueError(f&#34;Element {source} exists is neither a file nor a dir, then what is it ?&#34;)

    if &#34;gcs&#34; not in self.fs_kind:
        raise ValueError(&#34;The calling instance of get() must be on GCS. To move a file localy, use the mv() method.&#34;)
    # noinspection PyUnresolvedReferences
    if type(loc) == TransparentPath and loc.fs_kind != &#34;local&#34;:
        raise ValueError(
            &#34;The second argument can not be a GCS &#34;
            &#34;TransparentPath. To move on gcs a file already&#34;
            &#34;on gcs, use mv(). To move a file from gcs, to&#34;
            &#34; local, use get()&#34;
        )
    if type(loc) != TransparentPath:
        loc = TransparentPath(
            loc,
            fs=&#34;local&#34;,
            notupdatecache=self.notupdatecache,
            nocheck=self.nocheck,
            when_checked=self.when_checked,
            when_updated=self.when_updated,
            update_expire=self.update_expire,
            check_expire=self.check_expire,
        )

    # noinspection PyProtectedMember
    if not self.exist():
        raise FileNotFoundError(f&#34;No such file or directory: {self}&#34;)

    if self.is_dir(exist=True):
        # Recursive fs.get does not find all existing elements, it seems, so overload it
        recursive(self, loc)
    else:
        self.fs.get(self.__fspath__(), loc.__fspath__())</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.get_absolute"><code class="name flex">
<span>def <span class="ident">get_absolute</span></span>(<span>self) ‑> <a title="transparentpath.gcsutils.transparentpath.TransparentPath" href="#transparentpath.gcsutils.transparentpath.TransparentPath">TransparentPath</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns self, since all TransparentPaths are absolute</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath" href="#transparentpath.gcsutils.transparentpath.TransparentPath">TransparentPath</a></code></dt>
<dd>self</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_absolute(self) -&gt; TransparentPath:
    &#34;&#34;&#34;Returns self, since all TransparentPaths are absolute

    Returns
    -------
    TransparentPath
        self

    &#34;&#34;&#34;
    return self</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.glob"><code class="name flex">
<span>def <span class="ident">glob</span></span>(<span>self, wildcard: str = '*', fast: bool = False, i_am_sure_i_am_a_dir: bool = False) ‑> Iterator[<a title="transparentpath.gcsutils.transparentpath.TransparentPath" href="#transparentpath.gcsutils.transparentpath.TransparentPath">TransparentPath</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of TransparentPath matching the wildcard pattern.</p>
<p>By default, the wildcard is '<em>'. It means 'thepath/</em>', so will glob in the directory.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>wildcard</code></strong> :&ensp;<code>str</code></dt>
<dd>The wilcard pattern to match, relative to self (Default value = "*")</dd>
<dt><strong><code>fast</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, does not check multiplicity when converting output paths to TransparentPath, significantly
speeding up the process (Default value = False)</dd>
<dt><strong><code>i_am_sure_i_am_a_dir</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, will not check that self points to a directory. Saves time.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Iterator[<a title="transparentpath.gcsutils.transparentpath.TransparentPath" href="#transparentpath.gcsutils.transparentpath.TransparentPath">TransparentPath</a>]</code></dt>
<dd>The list of items matching the pattern</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def glob(
    self, wildcard: str = &#34;*&#34;, fast: bool = False, i_am_sure_i_am_a_dir: bool = False
) -&gt; Iterator[TransparentPath]:
    &#34;&#34;&#34;Returns a list of TransparentPath matching the wildcard pattern.

    By default, the wildcard is &#39;*&#39;. It means &#39;thepath/*&#39;, so will glob in the directory.

    Parameters
    -----------
    wildcard: str
        The wilcard pattern to match, relative to self (Default value = &#34;*&#34;)

    fast: bool
        If True, does not check multiplicity when converting output paths to TransparentPath, significantly
        speeding up the process (Default value = False)
    i_am_sure_i_am_a_dir: bool
        If True, will not check that self points to a directory. Saves time.


    Returns
    --------
    Iterator[TransparentPath]
        The list of items matching the pattern

    &#34;&#34;&#34;

    if not i_am_sure_i_am_a_dir:
        if not self.is_dir():
            raise NotADirectoryError(&#34;The path must be a directory if you want to glob in it&#34;)

    if wildcard.startswith(&#34;/&#34;) or wildcard.startswith(&#34;\\&#34;):
        wildcard = wildcard[1:]

    if wildcard.startswith(&#34;**/*&#34;):
        wildcard = wildcard.replace(&#34;**/*&#34;, &#34;**&#34;)

    path_to_glob = (self.__path / wildcard).__fspath__()

    try:
        if fast:
            to_ret = map(self._cast_fast, self.fs.glob(path_to_glob))
        else:
            to_ret = map(self._cast_slow, self.fs.glob(path_to_glob))
    except TypeError as e:
        if &#34;list indices must be integers or slices, not str&#34; in str(e):
            to_ret = []
        else:
            raise e
    return to_ret</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.is_dir"><code class="name flex">
<span>def <span class="ident">is_dir</span></span>(<span>self, *args, **kwargs) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if self is a directory.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_dir(self, *args, **kwargs) -&gt; bool:
    &#34;&#34;&#34;Check if self is a directory.


    Returns
    -------
    bool

    &#34;&#34;&#34;
    if self.fs_kind == &#34;local&#34;:
        if str(self.path) == &#34;/&#34;:
            return True
        return self.__path.is_dir()
    else:
        if not self.exists():
            return False
        if self.is_file():
            return False
        return True</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.is_file"><code class="name flex">
<span>def <span class="ident">is_file</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if self is a file
On GCS, leaves are always files even if created with mkdir.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_file(self) -&gt; bool:
    &#34;&#34;&#34;Check if self is a file
    On GCS, leaves are always files even if created with mkdir.


    Returns
    -------
    bool

    &#34;&#34;&#34;

    if not self.exists():
        return False

    if self.fs_kind == &#34;local&#34;:
        return self.__path.is_file()
    else:
        # GCS is shit and sometimes needs to be checked twice
        if self.info()[&#34;type&#34;] == &#34;file&#34; and self.info()[&#34;type&#34;] == &#34;file&#34;:
            return True
        else:
            return False</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.isdir"><code class="name flex">
<span>def <span class="ident">isdir</span></span>(<span>self, *args, **kwargs) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isdir(self, *args, **kwargs) -&gt; bool:
    return self.is_dir()</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.isfile"><code class="name flex">
<span>def <span class="ident">isfile</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isfile(self) -&gt; bool:
    return self.is_file()</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.ls"><code class="name flex">
<span>def <span class="ident">ls</span></span>(<span>self, path_to_ls: str = '', fast: bool = False) ‑> Iterator[<a title="transparentpath.gcsutils.transparentpath.TransparentPath" href="#transparentpath.gcsutils.transparentpath.TransparentPath">TransparentPath</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Unlike glob, if on GCS, will also see directories.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path_to_ls</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to ls, relative to self (default value = "")</dd>
<dt><strong><code>fast</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, does not check multiplicity when converting output
paths to TransparentPath, significantly speeding up the process
(Default value = False)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Iterator[<a title="transparentpath.gcsutils.transparentpath.TransparentPath" href="#transparentpath.gcsutils.transparentpath.TransparentPath">TransparentPath</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ls(self, path_to_ls: str = &#34;&#34;, fast: bool = False) -&gt; Iterator[TransparentPath]:
    &#34;&#34;&#34;Unlike glob, if on GCS, will also see directories.


    Parameters
    -----------
    path_to_ls: str
        Path to ls, relative to self (default value = &#34;&#34;)
    fast: bool
        If True, does not check multiplicity when converting output
        paths to TransparentPath, significantly speeding up the process
        (Default value = False)


    Returns
    --------
    Iterator[TransparentPath]

    &#34;&#34;&#34;

    if isinstance(path_to_ls, TransparentPath):
        raise TypeError(&#34;Can not use a TransparentPath as a argument of ls() : TransparentPath are all absolute&#34;)

    if not self.is_dir():
        raise NotADirectoryError(&#34;The path must be a directory if you want to ls in it&#34;)

    if fast:
        to_ret = map(self._cast_fast, self.fs.ls(str(self / path_to_ls)))
    else:
        to_ret = map(self._cast_slow, self.fs.ls(str(self / path_to_ls)))
    return to_ret</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.mkbucket"><code class="name flex">
<span>def <span class="ident">mkbucket</span></span>(<span>self, name: Optional[str] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mkbucket(self, name: Optional[str] = None) -&gt; None:
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.mkdir"><code class="name flex">
<span>def <span class="ident">mkdir</span></span>(<span>self, present: str = 'ignore', **kwargs) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Creates the directory corresponding to self if does not exist</p>
<p>Remember that leaves are always files on GCS, so can not create a directory on GCS. Thus, the function will
have no effect on GCS.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>present</code></strong> :&ensp;<code>str</code></dt>
<dd>What to do if there is already something at self. Can be "raise" or "ignore" (Default value = "ignore")</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>The kwargs to pass to file system's mkdir method</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mkdir(self, present: str = &#34;ignore&#34;, **kwargs) -&gt; None:
    &#34;&#34;&#34;Creates the directory corresponding to self if does not exist

    Remember that leaves are always files on GCS, so can not create a directory on GCS. Thus, the function will
    have no effect on GCS.


    Parameters
    ----------
    present: str
        What to do if there is already something at self. Can be &#34;raise&#34; or &#34;ignore&#34; (Default value = &#34;ignore&#34;)

    kwargs
        The kwargs to pass to file system&#39;s mkdir method


    Returns
    -------
    None

    &#34;&#34;&#34;

    if present != &#34;raise&#34; and present != &#34;ignore&#34;:
        raise ValueError(f&#34;Unexpected value for argument &#39;present&#39; : {present}&#34;)

    if self.exists():
        if self.is_dir() and present == &#34;raise&#34;:
            raise FileExistsError(f&#34;There is already a directory at {self}&#34;)
        if not self.is_dir():
            raise FileExistsError(f&#34;There is already an object at {self} and it is not a  directory&#34;)
        return

    for parent in reversed(self.parents):
        thefile = TransparentPath(
            parent,
            fs=self.fs_kind,
            bucket=self.bucket,
            notupdatecache=self.notupdatecache,
            nocheck=self.nocheck,
            when_checked=self.when_checked,
            when_updated=self.when_updated,
            update_expire=self.update_expire,
            check_expire=self.check_expire,
        )
        if thefile.is_file():
            raise FileExistsError(
                &#34;A parent directory can not be created because there is already a file at&#34; f&#34; {thefile}&#34;
            )

    if self.fs_kind == &#34;local&#34;:
        # Use _obj_missing instead of callign mkdir directly because
        # file systems mkdir has some kwargs with different name than
        # pathlib.Path&#39;s  mkdir, and this is handled in _obj_missing
        self._obj_missing(&#34;mkdir&#34;, kind=&#34;translate&#34;, **kwargs)
    else:
        # Does not mean anything to create a directory on GCS
        pass</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.mv"><code class="name flex">
<span>def <span class="ident">mv</span></span>(<span>self, other: Union[str, pathlib.Path, <a title="transparentpath.gcsutils.transparentpath.TransparentPath" href="#transparentpath.gcsutils.transparentpath.TransparentPath">TransparentPath</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>Used to move a file or a directory. Works between any filesystems.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mv(self, other: Union[str, Path, TransparentPath]):
    &#34;&#34;&#34;Used to move a file or a directory. Works between any filesystems.&#34;&#34;&#34;

    if not type(other) == TransparentPath:
        other = TransparentPath(
            other,
            fs=self.fs_kind,
            bucket=self.bucket,
            notupdatecache=self.notupdatecache,
            nocheck=self.nocheck,
            when_checked=self.when_checked,
            when_updated=self.when_updated,
            update_expire=self.update_expire,
            check_expire=self.check_expire,
            token=self.token,
        )

    if other.fs_kind != self.fs_kind:
        if self.fs_kind == &#34;local&#34;:
            self.put(other)
            self.rm(absent=&#34;raise&#34;, ignore_kind=True)
        else:
            self.get(other)
            self.rm(absent=&#34;raise&#34;, ignore_kind=True)
        return

    # Do not use filesystem&#39;s move, for it is coded by apes and is not able to use recursive properly
    # self.fs.mv(self.__fspath__(), other, **kwargs)

    # noinspection PyProtectedMember
    if not self.exist():
        raise FileNotFoundError(f&#34;No such file or directory: {self}&#34;)

    if self.is_file():
        self.fs.mv(self.__fspath__(), other)
        return

    for stuff in list(self.glob(&#34;**/*&#34;, fast=True)):
        # noinspection PyUnresolvedReferences
        if not stuff.is_file():
            continue
        # noinspection PyUnresolvedReferences
        relative = stuff.split(f&#34;/{self.name}/&#34;)[-1]
        newpath = other / relative
        newpath.parent.mkdir(recursive=True)
        self.fs.mv(stuff.__fspath__(), newpath)</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.put"><code class="name flex">
<span>def <span class="ident">put</span></span>(<span>self, dst: Union[str, pathlib.Path, <a title="transparentpath.gcsutils.transparentpath.TransparentPath" href="#transparentpath.gcsutils.transparentpath.TransparentPath">TransparentPath</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>used to push a local file to the cloud. Does not remove the local file.</p>
<p>self must be a local TransparentPath. If dst is a TransparentPath, it must be on GCS. If it is a pathlib.Path
or a str, it will be casted into a GCS TransparentPath, so a gcs file system must have been set up before.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put(self, dst: Union[str, Path, TransparentPath]):
    &#34;&#34;&#34;used to push a local file to the cloud. Does not remove the local file.

    self must be a local TransparentPath. If dst is a TransparentPath, it must be on GCS. If it is a pathlib.Path
    or a str, it will be casted into a GCS TransparentPath, so a gcs file system must have been set up before. &#34;&#34;&#34;
    if not self.fs_kind == &#34;local&#34;:
        raise ValueError(
            &#34;The calling instance of put() must be local. &#34;
            &#34;To move on gcs a file already on gcs, use mv(&#34;
            &#34;). To move a file from gcs, to local, use get(&#34;
            &#34;). &#34;
        )
    # noinspection PyUnresolvedReferences
    if type(dst) == TransparentPath and &#34;gcs&#34; not in dst.fs_kind:
        raise ValueError(
            &#34;The second argument can not be a local TransparentPath. To move a file localy, use the mv() method.&#34;
        )
    if type(dst) != TransparentPath:
        if TransparentPath.remote_prefix not in str(dst):
            if &#34;gcs&#34; not in &#34;&#34;.join(TransparentPath.fss):
                raise ValueError(&#34;You need to set up a gcs file system before using the put() command.&#34;)
            dst = TransparentPath(dst, fs=&#34;gcs&#34;)
        else:
            dst = TransparentPath(dst)

    # noinspection PyProtectedMember
    if not self.exist():
        raise FileNotFoundError(f&#34;No such file or directory: {self}&#34;)

    if self.is_dir():
        for item in self.glob(&#34;/*&#34;):
            # noinspection PyUnresolvedReferences
            item.put(dst / item.name)
    else:
        with open(self, &#34;rb&#34;) as f1:
            with open(dst, &#34;wb&#34;) as f2:
                data = True
                while data:
                    data = f1.read(self.blocksize)
                    f2.write(data)</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, *args, get_obj: bool = False, use_pandas: bool = False, use_dask: bool = False, **kwargs) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Method used to read the content of the file located at self</p>
<p>Will raise FileNotFound error if there is no file. Calls a specific method to read self based on the suffix
of self.path:
1: .csv : will use pandas's read_csv
2: .parquet : will use pandas's read_parquet with pyarrow engine
3: .hdf5 or .h5 : will use h5py.File or pd.HDFStore (if use_pandas = True). Since it does not support
remote file systems, the file will be downloaded localy in a tmp file read, then removed.
4: .json : will use open() method to get file content then json.loads to get a dict
5: .xlsx : will use pd.read_excel
6: any other suffix : will return a IO buffer to read from, or the string contained in the file if
get_obj is False.</p>
<p>For any of the reading method, the appropriate packages need to have been installed by calling
<code>pip install <a title="transparentpath" href="../index.html">transparentpath</a>[something]</code>
The possibilities for 'something' are 'pandas-csv', 'pandas-parquet', 'pandas-excel', 'hdf5', 'json', 'dask'.
You can install all possible packages by putting 'all' in place of 'something'.</p>
<p>The default installation of transperantpath is 'vanilla', which will only support read and write of text
or binary files, and the use of with open(&hellip;).</p>
<p>If self.enable_caching is True, will either save in tmp file (if self.caching == "tmpfile") or store the read
data in a dict (if self.caching == "ram"), then if the path have already been read, will just return the
previously stored data</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>get_obj</code></strong> :&ensp;<code>bool</code></dt>
<dd>Only relevant for files that are not csv, parquet nor HDF5. If True returns the IO Buffer,
else the string contained in the IO Buffer (Default value = False)</dd>
<dt><strong><code>use_pandas</code></strong> :&ensp;<code>bool</code></dt>
<dd>Must pass it as True if hdf5 file was written using HDFStore and not h5py.File (Default value = False)</dd>
<dt><strong><code>use_dask</code></strong> :&ensp;<code>bool</code></dt>
<dd>To return a Dask DataFrame instead of a pandas DataFrame. Only makes sense if file suffix is xlsx, csv,
parquet. (Default value = False)</dd>
</dl>
<p>args:
any args to pass to the underlying reading method
kwargs:
any kwargs to pass to the underlying reading method</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(
    self,
    *args,
    get_obj: bool = False,
    use_pandas: bool = False,
    use_dask: bool = False,
    **kwargs,
) -&gt; Any:
    &#34;&#34;&#34;Method used to read the content of the file located at self

    Will raise FileNotFound error if there is no file. Calls a specific method to read self based on the suffix
    of self.path:
        1: .csv : will use pandas&#39;s read_csv
        2: .parquet : will use pandas&#39;s read_parquet with pyarrow engine
        3: .hdf5 or .h5 : will use h5py.File or pd.HDFStore (if use_pandas = True). Since it does not support
        remote file systems, the file will be downloaded localy in a tmp file read, then removed.
        4: .json : will use open() method to get file content then json.loads to get a dict
        5: .xlsx : will use pd.read_excel
        6: any other suffix : will return a IO buffer to read from, or the string contained in the file if
        get_obj is False.

    For any of the reading method, the appropriate packages need to have been installed by calling
    `pip install transparentpath[something]`
    The possibilities for &#39;something&#39; are &#39;pandas-csv&#39;, &#39;pandas-parquet&#39;, &#39;pandas-excel&#39;, &#39;hdf5&#39;, &#39;json&#39;, &#39;dask&#39;.
    You can install all possible packages by putting &#39;all&#39; in place of &#39;something&#39;.

    The default installation of transperantpath is &#39;vanilla&#39;, which will only support read and write of text
     or binary files, and the use of with open(...).

    If self.enable_caching is True, will either save in tmp file (if self.caching == &#34;tmpfile&#34;) or store the read
    data in a dict (if self.caching == &#34;ram&#34;), then if the path have already been read, will just return the
    previously stored data

    Parameters
    ----------
    get_obj: bool
        Only relevant for files that are not csv, parquet nor HDF5. If True returns the IO Buffer,
        else the string contained in the IO Buffer (Default value = False)
    use_pandas: bool
        Must pass it as True if hdf5 file was written using HDFStore and not h5py.File (Default value = False)
    use_dask: bool
        To return a Dask DataFrame instead of a pandas DataFrame. Only makes sense if file suffix is xlsx, csv,
        parquet. (Default value = False)
    args:
        any args to pass to the underlying reading method
    kwargs:
        any kwargs to pass to the underlying reading method

    Returns
    -------
    Any
    &#34;&#34;&#34;
    if self.enable_caching:
        if self.caching == &#34;ram&#34;:
            if self.__hash__() in TransparentPath.cached_data_dict.keys():
                return TransparentPath.cached_data_dict[self.__hash__()][&#34;data&#34;]
        elif self.caching == &#34;tmpfile&#34; and self.fs_kind != &#34;local&#34;:
            if self.__hash__() in TransparentPath.cached_data_dict.keys():
                return TransparentPath(
                    TransparentPath.cached_data_dict[self.__hash__()][&#34;file&#34;].name, fs=&#34;local&#34;
                ).read(*args, get_obj, use_pandas, use_dask, **kwargs)
    if self.suffix == &#34;.csv&#34;:
        ret = self.read_csv(use_dask=use_dask, **kwargs)
        self.caching_saver(
            ret, args, kwargs.update({&#34;use_pandas&#34;: use_pandas, &#34;use_dask&#34;: use_dask, &#34;get_obj&#34;: get_obj})
        )
        return ret
    elif self.suffix == &#34;.parquet&#34;:
        index_col = None
        if &#34;index_col&#34; in kwargs:
            index_col = kwargs[&#34;index_col&#34;]
            del kwargs[&#34;index_col&#34;]
        # noinspection PyNoneFunctionAssignment
        content = self.read_parquet(use_dask=use_dask, **kwargs)
        if index_col:
            # noinspection PyUnresolvedReferences
            content.set_index(content.columns[index_col])
        self.caching_saver(
            content, args, kwargs.update({&#34;use_pandas&#34;: use_pandas, &#34;use_dask&#34;: use_dask, &#34;get_obj&#34;: get_obj})
        )
        return content
    elif self.suffix == &#34;.hdf5&#34; or self.suffix == &#34;.h5&#34;:
        ret = self.read_hdf5(use_pandas=use_pandas, use_dask=use_dask, **kwargs)
        self.caching_saver(
            ret, args, kwargs.update({&#34;use_pandas&#34;: use_pandas, &#34;use_dask&#34;: use_dask, &#34;get_obj&#34;: get_obj})
        )
        return ret
    elif self.suffix == &#34;.json&#34;:
        ret = self.read_json(*args, get_obj=get_obj, **kwargs)
        self.caching_saver(
            ret, args, kwargs.update({&#34;use_pandas&#34;: use_pandas, &#34;use_dask&#34;: use_dask, &#34;get_obj&#34;: get_obj})
        )
        return ret
    elif self.suffix in [&#34;.xlsx&#34;, &#34;.xls&#34;, &#34;.xlsm&#34;]:
        ret = self.read_excel(use_dask=use_dask, **kwargs)
        self.caching_saver(
            ret, args, kwargs.update({&#34;use_pandas&#34;: use_pandas, &#34;use_dask&#34;: use_dask, &#34;get_obj&#34;: get_obj})
        )
        return ret
    else:
        ret = self.read_text(*args, get_obj=get_obj, **kwargs)
        self.caching_saver(
            ret, args, kwargs.update({&#34;use_pandas&#34;: use_pandas, &#34;use_dask&#34;: use_dask, &#34;get_obj&#34;: get_obj})
        )
        return ret</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.read_csv"><code class="name flex">
<span>def <span class="ident">read_csv</span></span>(<span>self, *args, **kwargs) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_csv(self, *args, **kwargs) -&gt; Any:
    use_dask = False
    if &#34;use_dask&#34; in kwargs:
        use_dask = kwargs[&#34;use_dask&#34;]
        del kwargs[&#34;use_dask&#34;]
    if use_dask:
        return self.read_csv_dask(*args, **kwargs)
    else:
        return self.read_csv_classic(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.read_csv_classic"><code class="name flex">
<span>def <span class="ident">read_csv_classic</span></span>(<span>self, **kwargs) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, **kwargs) -&gt; pd.DataFrame:

    if not self.is_file():
        raise FileNotFoundError(f&#34;Could not find file {self}&#34;)

    # noinspection PyTypeChecker,PyUnresolvedReferences
    try:

        check_kwargs(pd.read_csv, kwargs)
        with self.fs.open(self.__fspath__()) as f:
            return pd.read_csv(f, **kwargs)

    except pd.errors.ParserError:
        # noinspection PyUnresolvedReferences
        raise pd.errors.ParserError(
            &#34;Could not read data. Most likely, the file is encrypted.&#34;
            &#34; Ask your cloud manager to remove encryption on it.&#34;
        )</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.read_csv_dask"><code class="name flex">
<span>def <span class="ident">read_csv_dask</span></span>(<span>self, **kwargs) ‑> dask.dataframe.core.DataFrame</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_csv(self, **kwargs) -&gt; dd.DataFrame:

    if not self.nocheck:
        self._check_multiplicity()

    check_dask(self)

    if self.is_file():
        to_use = self
    else:
        to_use = self.with_suffix(&#34;&#34;)

    index_col, parse_dates, kwargs = get_index_and_date_from_kwargs(**kwargs)
    check_kwargs(dd.read_csv, kwargs)
    return apply_index_and_date_dd(index_col, parse_dates, dd.read_csv(to_use.__fspath__(), **kwargs))</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.read_excel"><code class="name flex">
<span>def <span class="ident">read_excel</span></span>(<span>self, *args, **kwargs) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_excel(self, *args, **kwargs) -&gt; Any:
    use_dask = False
    if &#34;use_dask&#34; in kwargs:
        use_dask = kwargs[&#34;use_dask&#34;]
        del kwargs[&#34;use_dask&#34;]
    if use_dask:
        return self.read_excel_dask(*args, **kwargs)
    else:
        return self.read_excel_classic(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.read_excel_classic"><code class="name flex">
<span>def <span class="ident">read_excel_classic</span></span>(<span>self, **kwargs) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, **kwargs) -&gt; pd.DataFrame:

    if not self.is_file():
        raise FileNotFoundError(f&#34;Could not find file {self}&#34;)

    check_kwargs(pd.read_excel, kwargs)
    # noinspection PyTypeChecker,PyUnresolvedReferences
    try:
        if self.fs_kind == &#34;local&#34;:
            return pd.read_excel(self.__fspath__(), **kwargs)
        else:
            f = tempfile.NamedTemporaryFile(delete=False, suffix=self.suffix)
            f.close()  # deletes the tmp file, but we can still use its name
            self.get(f.name)
            data = pd.read_excel(f.name, **kwargs)
            Path(f.name).unlink()
            return data
    except pd.errors.ParserError:
        # noinspection PyUnresolvedReferences
        raise pd.errors.ParserError(
            &#34;Could not read data. Most likely, the file is encrypted.&#34;
            &#34; Ask your cloud manager to remove encryption on it.&#34;
        )</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.read_excel_dask"><code class="name flex">
<span>def <span class="ident">read_excel_dask</span></span>(<span>self, **kwargs) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_excel(self, **kwargs) -&gt; pd.DataFrame:

    if not excel_ok:
        raise ImportError(errormessage_excel)

    # noinspection PyProtectedMember
    if not self.nocheck:
        self._check_multiplicity()

    check_dask(self)

    check_kwargs(pd.read_excel, kwargs)
    # noinspection PyTypeChecker,PyUnresolvedReferences
    try:
        if self.fs_kind == &#34;local&#34;:
            parts = delayed(pd.read_excel)(self.__fspath__(), **kwargs)
            return dd.from_delayed(parts)
        else:
            f = tempfile.NamedTemporaryFile(delete=False, suffix=&#34;.xlsx&#34;)
            f.close()  # deletes the tmp file, but we can still use its name
            self.get(f.name)
            parts = delayed(pd.read_excel)(f.name, **kwargs)
            data = dd.from_delayed(parts)
            # We should not delete the tmp file, since dask does its operations lasily.
            return data
    except pd.errors.ParserError:
        # noinspection PyUnresolvedReferences
        raise pd.errors.ParserError(
            &#34;Could not read data. Most likely, the file is encrypted. Ask your cloud manager to remove encryption &#34;
            &#34;on it.&#34;
        )</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.read_hdf5"><code class="name flex">
<span>def <span class="ident">read_hdf5</span></span>(<span>self, *args, **kwargs) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_hdf5(self, *args, **kwargs) -&gt; Any:
    use_dask = False
    if &#34;use_dask&#34; in kwargs:
        use_dask = kwargs[&#34;use_dask&#34;]
        del kwargs[&#34;use_dask&#34;]
    if use_dask:
        return self.read_hdf5_dask(*args, **kwargs)
    else:
        return self.read_hdf5_classic(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.read_hdf5_classic"><code class="name flex">
<span>def <span class="ident">read_hdf5_classic</span></span>(<span>self: <a title="transparentpath.gcsutils.transparentpath.TransparentPath" href="#transparentpath.gcsutils.transparentpath.TransparentPath">TransparentPath</a>, use_pandas: bool = False, **kwargs) ‑> Union[h5py._hl.files.File, transparentpath.io._pandas.MyHDFStore]</span>
</code></dt>
<dd>
<div class="desc"><p>Reads a HDF5 file. Must have been created by h5py.File or pd.HDFStore (specify use_pandas=True if so)</p>
<p>Since h5py.File/pd.HDFStore does not support GCS, first copy it in a tmp file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>self</code></strong> :&ensp;<code><a title="transparentpath.gcsutils.transparentpath.TransparentPath" href="#transparentpath.gcsutils.transparentpath.TransparentPath">TransparentPath</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>use_pandas</code></strong> :&ensp;<code>bool</code></dt>
<dd>To use HDFStore instead of h5py.File (Default value = False)</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>The kwargs to pass to h5py.File/pd.HDFStore method, or to dask.dataframe.read_hdf()</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[h5py.File, MyHDFStore]</code></dt>
<dd>Opened h5py.File/pd.HDFStore</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self: TransparentPath, use_pandas: bool = False, **kwargs,) -&gt; Union[h5py.File, MyHDFStore]:
    &#34;&#34;&#34;Reads a HDF5 file. Must have been created by h5py.File or pd.HDFStore (specify use_pandas=True if so)

    Since h5py.File/pd.HDFStore does not support GCS, first copy it in a tmp file.


    Parameters
    ----------
    self: TransparentPath

    use_pandas: bool
        To use HDFStore instead of h5py.File (Default value = False)

    kwargs
        The kwargs to pass to h5py.File/pd.HDFStore method, or to dask.dataframe.read_hdf()


    Returns
    -------
    Union[h5py.File, MyHDFStore]
        Opened h5py.File/pd.HDFStore

    &#34;&#34;&#34;

    mode = &#34;r&#34;
    if &#34;mode&#34; in kwargs:
        mode = kwargs[&#34;mode&#34;]
        del kwargs[&#34;mode&#34;]
    if &#34;r&#34; not in mode:
        raise ValueError(&#34;If using read_hdf5, mode must contain &#39;r&#39;&#34;)

    class_to_use = h5py.File
    if use_pandas:
        class_to_use = MyHDFStore

    if not self.is_file():
        raise FileNotFoundError(f&#34;Could not find file {self}&#34;)

    if self.fs_kind == &#34;local&#34;:
        # Do not check kwargs since HDFStore and h5py both accepct kwargs anyway
        data = class_to_use(self.path, mode=mode, **kwargs)
    else:
        f = tempfile.NamedTemporaryFile(delete=False, suffix=&#34;.hdf5&#34;)
        f.close()  # deletes the tmp file, but we can still use its name
        self.get(f.name)
        # Do not check kwargs since HDFStore and h5py both accepct kwargs anyway
        data = class_to_use(f.name, mode=mode, **kwargs)
        Path(f.name).unlink()
    return data</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.read_hdf5_dask"><code class="name flex">
<span>def <span class="ident">read_hdf5_dask</span></span>(<span>self, set_names: str = '', use_pandas: bool = False, **kwargs) ‑> dask.dataframe.core.DataFrame</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_hdf5(self, set_names: str = &#34;&#34;, use_pandas: bool = False, **kwargs) -&gt; dd.DataFrame:

    if not hdf5_ok:
        raise ImportError(errormessage_hdf5)

    if use_pandas:
        raise NotImplementedError(&#34;Using dask in transparentpath does not support pandas&#39;s HDFStore&#34;)

    mode = &#34;r&#34;
    if &#34;mode&#34; in kwargs:
        mode = kwargs[&#34;mode&#34;]
        del kwargs[&#34;mode&#34;]
    if &#34;r&#34; not in mode:
        raise ValueError(&#34;If using read_hdf5, mode must contain &#39;r&#39;&#34;)

    if not self.nocheck:
        self._check_multiplicity()

    check_dask(self)

    if len(set_names) == 0:
        raise ValueError(
            &#34;If using Dask, you must specify the dataset name to extract using set_names=&#39;aname&#39; or a wildcard.&#34;
        )

    check_kwargs(dd.read_hdf, kwargs)
    if self.fs_kind == &#34;local&#34;:
        return dd.read_hdf(pattern=self.__fspath__(), key=set_names, **kwargs)
    f = tempfile.NamedTemporaryFile(delete=False, suffix=&#34;.hdf5&#34;)
    f.close()  # deletes the tmp file, but we can still use its name to download the remote file locally
    self.get(f.name)
    data = self.__class__.cli.submit(dd.read_hdf, f.name, set_names, **kwargs)
    # Do not delete the tmp file, since dask tasks are delayed
    return data.result()</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, *args, get_obj, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, *args, get_obj, **kwargs):
    stringified = self.read_text(*args, get_obj=get_obj, **kwargs)
    dictified = json.loads(stringified, object_hook=json_obj_hook)
    if isinstance(dictified, str):
        try:
            dictified = json.loads(dictified)
        except TypeError:
            pass
    return dictified</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.read_parquet"><code class="name flex">
<span>def <span class="ident">read_parquet</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_parquet(self, *args, **kwargs):
    use_dask = False
    if &#34;use_dask&#34; in kwargs:
        use_dask = kwargs[&#34;use_dask&#34;]
        del kwargs[&#34;use_dask&#34;]
    if use_dask:
        return self.read_parquet_dask(*args, **kwargs)
    else:
        return self.read_parquet_classic(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.read_parquet_classic"><code class="name flex">
<span>def <span class="ident">read_parquet_classic</span></span>(<span>self, **kwargs) ‑> Union[pandas.core.frame.DataFrame, pandas.core.series.Series]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, **kwargs) -&gt; Union[pd.DataFrame, pd.Series]:

    if not self.is_file():
        raise FileNotFoundError(f&#34;Could not find file {self}&#34;)

    index_col, parse_dates, kwargs = get_index_and_date_from_kwargs(**kwargs)

    check_kwargs(pd.read_parquet, kwargs)
    if &#34;engine&#34; in kwargs:
        engine = kwargs[&#34;engine&#34;]
        del kwargs[&#34;engine&#34;]
    else:
        engine = &#34;pyarrow&#34;
    if self.fs_kind == &#34;local&#34;:
        return apply_index_and_date(
            index_col, parse_dates, pd.read_parquet(self.__fspath__(), engine=engine, **kwargs)
        )

    elif engine == &#34;pyarrow&#34;:
        return apply_index_and_date(
            index_col, parse_dates, pd.read_parquet(self.open(&#34;rb&#34;), engine=&#34;pyarrow&#34;, **kwargs)
        )
    else:
        f = tempfile.NamedTemporaryFile(delete=False, suffix=&#34;.parquet&#34;)
        f.close()  # deletes the tmp file, but we can still use its name
        self.get(f.name)
        data = pd.read_parquet(f.name, engine=engine, **kwargs)
        Path(f.name).unlink()
        return apply_index_and_date(index_col, parse_dates, data)</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.read_parquet_dask"><code class="name flex">
<span>def <span class="ident">read_parquet_dask</span></span>(<span>self, **kwargs) ‑> Union[dask.dataframe.core.DataFrame, dask.dataframe.core.Series]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_parquet(self, **kwargs) -&gt; Union[dd.DataFrame, dd.Series]:

    if not parquet_ok:
        raise ImportError(errormessage_parquet)

    index_col, parse_dates, kwargs = get_index_and_date_from_kwargs(**kwargs)

    if not self.nocheck:
        self._check_multiplicity()

    check_dask(self)

    if self.is_file():
        to_use = self
    else:
        to_use = self.with_suffix(&#34;&#34;)
    check_kwargs(dd.read_parquet, kwargs)
    return apply_index_and_date_dd(
        index_col, parse_dates, dd.read_parquet(to_use.__fspath__(), engine=&#34;pyarrow&#34;, **kwargs)
    )</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.read_text"><code class="name flex">
<span>def <span class="ident">read_text</span></span>(<span>self, *args, size: int = -1, get_obj: bool = False, **kwargs) ‑> Union[str, IO]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_text(self, *args, size: int = -1, get_obj: bool = False, **kwargs) -&gt; Union[str, IO]:
    if not self.is_file():
        raise FileNotFoundError(f&#34;Could not find file {self}&#34;)

    byte_mode = True
    if len(args) == 0:
        byte_mode = False
        args = (&#34;rb&#34;,)
    if &#34;b&#34; not in args[0]:
        byte_mode = False
        args[0] += &#34;b&#34;
    if get_obj:
        return self.open(*args, **kwargs)

    with self.open(*args, **kwargs) as f:
        to_ret = f.read(size)
        if not byte_mode:
            to_ret = to_ret.decode()
    return to_ret</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.refresh_cache"><code class="name flex">
<span>def <span class="ident">refresh_cache</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>update tp</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh_cache(self) -&gt; None:
    &#34;&#34;&#34;
    update tp
    &#34;&#34;&#34;
    if self.enable_caching:
        if self.__hash__() in TransparentPath.cached_data_dict.keys():
            arg = TransparentPath.cached_data_dict[self.__hash__()][&#34;arg&#34;]
            kwarg = TransparentPath.cached_data_dict[self.__hash__()][&#34;kwarg&#34;]
            self.uncache()
            self.read(*arg, **kwarg)
        else:
            warnings.warn(f&#34;{self.__hash__()} is not in cache&#34;, TPCachingWarning)</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.rm"><code class="name flex">
<span>def <span class="ident">rm</span></span>(<span>self, absent: str = 'raise', ignore_kind: bool = False, **kwargs) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Removes the object pointed to by self if exists.
Remember that leaves are always files on GCS, so rm will remove the path if it is a leaf on GCS</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>absent</code></strong> :&ensp;<code>str</code></dt>
<dd>What to do if trying to remove an item that does not exist. Can
be 'raise' or 'ignore' (Default value = 'raise')</dd>
<dt><strong><code>ignore_kind</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, will remove anything pointed by self. If False,
will raise an error if self points to a file and 'recursive' was
specified in kwargs, or if self points to a dir and 'recursive'
was not specified (Default value = False)</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>The kwargs to pass to file system's rm method</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rm(self, absent: str = &#34;raise&#34;, ignore_kind: bool = False, **kwargs) -&gt; None:
    &#34;&#34;&#34;Removes the object pointed to by self if exists.
    Remember that leaves are always files on GCS, so rm will remove the path if it is a leaf on GCS


    Parameters
    ----------
    absent: str
        What to do if trying to remove an item that does not exist. Can
        be &#39;raise&#39; or &#39;ignore&#39; (Default value = &#39;raise&#39;)

    ignore_kind: bool
        If True, will remove anything pointed by self. If False,
        will raise an error if self points to a file and &#39;recursive&#39; was
        specified in kwargs, or if self points to a dir and &#39;recursive&#39;
        was not specified (Default value = False)

    kwargs
        The kwargs to pass to file system&#39;s rm method


    Returns
    -------
    None

    &#34;&#34;&#34;

    if absent != &#34;raise&#34; and absent != &#34;ignore&#34;:
        raise ValueError(f&#34;Unexpected value for argument &#39;absent&#39; : {absent}&#34;)

    # Asked to remove a directory...
    recursive = kwargs.get(&#34;recursive&#34;, False)

    if recursive:
        if not self.is_dir():
            # ...but self points to something that is not a directory!
            if self.exists():
                # Delete anyway
                if ignore_kind:
                    del kwargs[&#34;recursive&#34;]
                    self.rm(absent, **kwargs)
                # or raise
                else:
                    raise NotADirectoryError(&#34;The path does not point to a directory!&#34;)
            # ...but self points to something that does not exist!
            else:
                if absent == &#34;raise&#34;:
                    raise NotADirectoryError(&#34;There is no directory here!&#34;)
                else:
                    return
        # ...deletes the directory
        else:
            try:
                self.fs.rm(self.__fspath__(), **kwargs)
            except OSError as e:
                if &#34;not found&#34; in str(e).lower():
                    # It is possible that another parallel program deleted the object, in that case just pass
                    pass
                else:
                    raise e
    # Asked to remove a file...
    else:
        # ...but self points to a directory!
        if self.is_dir():
            # Delete anyway
            if ignore_kind:
                kwargs[&#34;recursive&#34;] = True
                self.rm(absent=absent, ignore_kind=True, **kwargs)
            # or raise
            else:
                raise IsADirectoryError(&#34;The path points to a directory&#34;)
        else:
            # ... but nothing is at self
            if not self.exists():
                if absent == &#34;raise&#34;:
                    raise FileNotFoundError(f&#34;Could not find file {self}&#34;)
                else:
                    return
            else:
                try:
                    self.fs.rm(self.__fspath__(), **kwargs)
                except OSError as e:
                    if &#34;not found&#34; in str(e).lower():
                        # It is possible that another parallel program deleted the object, in that case just pass
                        pass
                    else:
                        raise e</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.rmbucket"><code class="name flex">
<span>def <span class="ident">rmbucket</span></span>(<span>self, name: Optional[str] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rmbucket(self, name: Optional[str] = None) -&gt; None:
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.rmdir"><code class="name flex">
<span>def <span class="ident">rmdir</span></span>(<span>self, absent: str = 'raise', ignore_kind: bool = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Removes the directory corresponding to self if exists
Remember that leaves are always files on GCS, so rmdir will never remove a leaf on GCS</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>absent</code></strong> :&ensp;<code>str</code></dt>
<dd>What to do if trying to remove an item that does not exist. Can
be 'raise' or 'ignore' (Default value = 'raise')</dd>
<dt><strong><code>ignore_kind</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, will remove anything pointed by self. If False,
will raise an error if self points to a file and 'recursive' was
specified in kwargs, or if self point to a dir and 'recursive'
was not specified (Default value = False)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rmdir(self, absent: str = &#34;raise&#34;, ignore_kind: bool = False) -&gt; None:
    &#34;&#34;&#34;Removes the directory corresponding to self if exists
    Remember that leaves are always files on GCS, so rmdir will never remove a leaf on GCS


    Parameters
    ----------
    absent: str
        What to do if trying to remove an item that does not exist. Can
        be &#39;raise&#39; or &#39;ignore&#39; (Default value = &#39;raise&#39;)

    ignore_kind: bool
        If True, will remove anything pointed by self. If False,
        will raise an error if self points to a file and &#39;recursive&#39; was
        specified in kwargs, or if self point to a dir and &#39;recursive&#39;
        was not specified (Default value = False)

    &#34;&#34;&#34;
    self.rm(absent=absent, ignore_kind=ignore_kind, recursive=True)</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.stat"><code class="name flex">
<span>def <span class="ident">stat</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Calls file system's stat method and translates the key to os.stat_result() keys</p>
<p>Returns empty dict of path does not point to anything</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stat(self) -&gt; dict:
    &#34;&#34;&#34;Calls file system&#39;s stat method and translates the key to os.stat_result() keys

    Returns empty dict of path does not point to anything
    &#34;&#34;&#34;

    if not self.exist():
        return {}

    key_translation = {
        &#34;size&#34;: &#34;st_size&#34;,
        &#34;timeCreated&#34;: &#34;st_ctime&#34;,
        &#34;updated&#34;: &#34;st_mtime&#34;,
        &#34;created&#34;: &#34;st_ctime&#34;,
        &#34;mode&#34;: &#34;st_mode&#34;,
        &#34;uid&#34;: &#34;st_uid&#34;,
        &#34;gid&#34;: &#34;st_gid&#34;,
        &#34;mtime&#34;: &#34;st_mtime&#34;,
    }

    stat = self.fs.stat(self.__fspath__())
    statkeys = list(stat.keys())
    for key in statkeys:
        if key in key_translation:
            if key == &#34;timeCreated&#34; or key == &#34;updated&#34;:
                dt = datetime.strptime(stat[key], &#34;%Y-%m-%dT%H:%M:%S.%fZ&#34;)
                stat[key] = dt.timestamp()
            if key == &#34;created&#34; or key == &#34;mtime&#34;:
                stat[key] = int(stat[key])
            stat[key_translation[key]] = stat[key]

    for key in key_translation.values():
        if key not in stat:
            stat[key] = None

    return stat</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.to_csv"><code class="name flex">
<span>def <span class="ident">to_csv</span></span>(<span>self, data, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_csv(self, data, *args, **kwargs):
    if &#34;dask&#34; in str(type(data)):
        return self.to_csv_dask(data, *args, **kwargs)
    else:
        self.to_csv_classic(data, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.to_csv_classic"><code class="name flex">
<span>def <span class="ident">to_csv_classic</span></span>(<span>self, data: Union[pandas.core.frame.DataFrame, pandas.core.series.Series], overwrite: bool = True, present: str = 'ignore', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(
    self, data: Union[pd.DataFrame, pd.Series], overwrite: bool = True, present: str = &#34;ignore&#34;, **kwargs,
):

    if self.suffix != &#34;.csv&#34;:
        warnings.warn(f&#34;path {self} does not have &#39;.csv&#39; as suffix while using to_csv. The path will be &#34;
                      f&#34;changed to a path with &#39;.csv&#39; as suffix&#34;)
        self.change_suffix(&#34;.csv&#34;)

    if not overwrite and self.is_file() and present != &#34;ignore&#34;:
        raise FileExistsError()

    check_kwargs(data.to_csv, kwargs)
    with self.fs.open(self.__fspath__(), &#34;w&#34;) as f:
        data.to_csv(f, **kwargs)</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.to_csv_dask"><code class="name flex">
<span>def <span class="ident">to_csv_dask</span></span>(<span>self, data: dask.dataframe.core.DataFrame, overwrite: bool = True, present: str = 'ignore', **kwargs) ‑> Optional[None]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_csv(
    self, data: dd.DataFrame, overwrite: bool = True, present: str = &#34;ignore&#34;, **kwargs,
) -&gt; Union[None, List[TransparentPath]]:

    if self.suffix != &#34;.csv&#34;:
        warnings.warn(f&#34;path {self} does not have &#39;.csv&#39; as suffix while using to_csv. The path will be &#34;
                      f&#34;changed to a path with &#39;.csv&#39; as suffix&#34;)
        self.change_suffix(&#34;.csv&#34;)

    if not self.nocheck:
        self._check_multiplicity()

    if not overwrite and self.is_file() and present != &#34;ignore&#34;:
        raise FileExistsError()

    if self.__class__.cli is None:
        self.__class__.cli = client.Client()
    check_kwargs(dd.to_csv, kwargs)
    path_to_save = self
    if not path_to_save.stem.endswith(&#34;*&#34;):
        path_to_save = path_to_save.parent / (path_to_save.stem + &#34;_*.csv&#34;)
    # noinspection PyTypeChecker
    futures = self.__class__.cli.submit(dd.to_csv, data, path_to_save.__fspath__(), **kwargs)
    outfiles = [
        TransparentPath(f, fs=self.fs_kind, bucket=self.bucket) for f in futures.result()
    ]
    if len(outfiles) == 1:
        outfiles[0].mv(self)
    else:
        return outfiles</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.to_excel"><code class="name flex">
<span>def <span class="ident">to_excel</span></span>(<span>self, data, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_excel(self, data, *args, **kwargs):
    if &#34;dask&#34; in str(type(data)):
        self.to_excel_dask(data, *args, **kwargs)
    else:
        self.to_excel_classic(data, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.to_excel_classic"><code class="name flex">
<span>def <span class="ident">to_excel_classic</span></span>(<span>self, data: Union[pandas.core.frame.DataFrame, pandas.core.series.Series], overwrite: bool = True, present: str = 'ignore', **kwargs) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(
    self, data: Union[pd.DataFrame, pd.Series], overwrite: bool = True, present: str = &#34;ignore&#34;, **kwargs,
) -&gt; None:

    if self.suffix != &#34;.xlsx&#34; and self.suffix != &#34;.xls&#34; and self.suffix != &#34;.xlsm&#34;:
        warnings.warn(f&#34;path {self} does not have &#39;.xls(x,m)&#39; as suffix while using to_excel. The path will be &#34;
                      f&#34;changed to a path with &#39;.xlsx&#39; as suffix&#34;)
        self.change_suffix(&#34;.xlsx&#34;)

    if not overwrite and self.is_file() and present != &#34;ignore&#34;:
        raise FileExistsError()

    # noinspection PyTypeChecker

    if self.fs_kind == &#34;local&#34;:
        data.to_excel(self.__fspath__(), **kwargs)
    else:
        with tempfile.NamedTemporaryFile(delete=True, suffix=self.suffix) as f:
            check_kwargs(data.to_excel, kwargs)
            data.to_excel(f.name, **kwargs)
            TransparentPath(
                path=f.name,
                fs=&#34;local&#34;,
                notupdatecache=self.notupdatecache,
                nocheck=self.nocheck,
                when_checked=self.when_checked,
                when_updated=self.when_updated,
                update_expire=self.update_expire,
                check_expire=self.check_expire,
            ).put(self.path)</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.to_excel_dask"><code class="name flex">
<span>def <span class="ident">to_excel_dask</span></span>(<span>self, data: Union[pandas.core.frame.DataFrame, pandas.core.series.Series, dask.dataframe.core.DataFrame], overwrite: bool = True, present: str = 'ignore', **kwargs) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_excel(
    self,
    data: Union[pd.DataFrame, pd.Series, dd.DataFrame],
    overwrite: bool = True,
    present: str = &#34;ignore&#34;,
    **kwargs,
) -&gt; None:

    if not excel_ok:
        raise ImportError(errormessage_excel)

    if self.suffix != &#34;.xlsx&#34; and self.suffix != &#34;.xls&#34; and self.suffix != &#34;.xlsm&#34;:
        warnings.warn(f&#34;path {self} does not have &#39;.xls(x,m)&#39; as suffix while using to_excel. The path will be &#34;
                      f&#34;changed to a path with &#39;.xlsx&#39; as suffix&#34;)
        self.change_suffix(&#34;.xlsx&#34;)

    if not self.nocheck:
        self._check_multiplicity()

    if not overwrite and self.is_file() and present != &#34;ignore&#34;:
        raise FileExistsError()

    if self.fs_kind == &#34;local&#34;:
        if self.__class__.cli is None:
            self.__class__.cli = client.Client()
        check_kwargs(pd.DataFrame.to_excel, kwargs)
        parts = delayed(pd.DataFrame.to_excel)(data, self.__fspath__(), **kwargs)
        parts.compute()
        return
    else:
        with tempfile.NamedTemporaryFile(delete=True, suffix=&#34;.xlsx&#34;) as f:
            if TransparentPath.cli is None:
                TransparentPath.cli = client.Client()
            check_kwargs(pd.DataFrame.to_excel, kwargs)
            parts = delayed(pd.DataFrame.to_excel)(data, f.name, **kwargs)
            parts.compute()
            TransparentPath(path=f.name, fs=&#34;local&#34;, bucket=self.bucket).put(self.path)</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.to_hdf5"><code class="name flex">
<span>def <span class="ident">to_hdf5</span></span>(<span>self, data, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_hdf5(self, data, *args, **kwargs):
    if &#34;dask&#34; in str(type(data)):
        return self.to_hdf5_dask(data, *args, **kwargs)
    else:
        return self.to_hdf5_classic(data, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.to_hdf5_classic"><code class="name flex">
<span>def <span class="ident">to_hdf5_classic</span></span>(<span>self: <a title="transparentpath.gcsutils.transparentpath.TransparentPath" href="#transparentpath.gcsutils.transparentpath.TransparentPath">TransparentPath</a>, data: Any = None, set_name: str = None, use_pandas: bool = False, **kwargs) ‑> Union[None, h5py._hl.files.File, transparentpath.io._pandas.MyHDFStore]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>self</code></strong> :&ensp;<code><a title="transparentpath.gcsutils.transparentpath.TransparentPath" href="#transparentpath.gcsutils.transparentpath.TransparentPath">TransparentPath</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>Any</code></dt>
<dd>The data to store. Can be None, in that case an opened file is returned (Default value = None)</dd>
<dt><strong><code>set_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the dataset (Default value = None)</dd>
<dt><strong><code>use_pandas</code></strong> :&ensp;<code>bool</code></dt>
<dd>To use pd.HDFStore object instead of h5py.File (Default = False)</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[None, pd.HDFStore, h5py.File]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(
    self: TransparentPath, data: Any = None, set_name: str = None, use_pandas: bool = False, **kwargs,
) -&gt; Union[None, h5py.File, MyHDFStore]:
    &#34;&#34;&#34;

    Parameters
    ----------
    self: TransparentPath
    data: Any
        The data to store. Can be None, in that case an opened file is returned (Default value = None)
    set_name: str
        The name of the dataset (Default value = None)
    use_pandas: bool
        To use pd.HDFStore object instead of h5py.File (Default = False)
    **kwargs

    Returns
    -------
    Union[None, pd.HDFStore, h5py.File]

    &#34;&#34;&#34;

    if self.suffix != &#34;.hdf5&#34; and self.suffix != &#34;h5&#34;:
        warnings.warn(f&#34;path {self} does not have &#39;.h(df)5&#39; as suffix while using to_hdf5. The path will be &#34;
                      f&#34;changed to a path with &#39;.hdf5&#39; as suffix&#34;)
        self.change_suffix(&#34;.hdf5&#34;)

    mode = &#34;w&#34;
    if &#34;mode&#34; in kwargs:
        mode = kwargs[&#34;mode&#34;]
        del kwargs[&#34;mode&#34;]

    if self.when_checked[&#34;used&#34;] and not self.nocheck:
        self._check_multiplicity()

    # If no data is specified, an HDF5 file is returned, opened in write mode, or any other specified mode.
    if data is None:

        class_to_use = MyHDFFile
        if use_pandas:
            class_to_use = MyHDFStore

        if self.fs_kind == &#34;local&#34;:
            return class_to_use(self.path, mode=mode, **kwargs)
        else:
            f = tempfile.NamedTemporaryFile(delete=True, suffix=&#34;.hdf5&#34;)
            return class_to_use(f, remote=self.path, mode=mode, **kwargs)
    else:

        if isinstance(data, dict):
            sets = data
        else:
            if set_name is None:
                set_name = &#34;data&#34;
            sets = {set_name: data}

        class_to_use = h5py.File
        if use_pandas:
            class_to_use = MyHDFStore

        if self.fs_kind == &#34;local&#34;:
            thefile = class_to_use(self.path, mode=mode, **kwargs)
            for aset in sets:
                thefile[aset] = sets[aset]
            thefile.close()
        else:
            with tempfile.NamedTemporaryFile(delete=True, suffix=&#34;.hdf5&#34;) as f:
                thefile = class_to_use(f.name, mode=mode, **kwargs)
                for aset in sets:
                    thefile[aset] = sets[aset]
                thefile.close()
                TransparentPath(
                    path=f.name,
                    fs=&#34;local&#34;,
                    notupdatecache=self.notupdatecache,
                    nocheck=self.nocheck,
                    when_checked=self.when_checked,
                    when_updated=self.when_updated,
                    update_expire=self.update_expire,
                    check_expire=self.check_expire,
                ).put(self.path)</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.to_hdf5_dask"><code class="name flex">
<span>def <span class="ident">to_hdf5_dask</span></span>(<span>self, data: Any = None, set_name: str = None, use_pandas: bool = False, **kwargs) ‑> Optional[None]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_hdf5(
    self, data: Any = None, set_name: str = None, use_pandas: bool = False, **kwargs,
) -&gt; Union[None, &#34;h5py.File&#34;]:

    if not hdf5_ok:
        raise ImportError(errormessage_hdf5)

    if use_pandas:
        raise NotImplementedError(&#34;TransparentPath does not support storing Dask objects in pandas&#39;s HDFStore yet.&#34;)

    if self.suffix != &#34;.hdf5&#34; and self.suffix != &#34;h5&#34;:
        warnings.warn(f&#34;path {self} does not have &#39;.h(df)5&#39; as suffix while using to_hdf5. The path will be &#34;
                      f&#34;changed to a path with &#39;.hdf5&#39; as suffix&#34;)
        self.change_suffix(&#34;.hdf5&#34;)

    if not self.nocheck:
        self._check_multiplicity()

    if self.__class__.cli is None:
        self.__class__.cli = client.Client()
    check_kwargs(dd.to_hdf, kwargs)

    mode = &#34;w&#34;
    if &#34;mode&#34; in kwargs:
        mode = kwargs[&#34;mode&#34;]
        del kwargs[&#34;mode&#34;]

    if isinstance(data, dict):
        sets = data
    else:
        if set_name is None:
            set_name = &#34;data&#34;
        sets = {set_name: data}

    if self.fs_kind == &#34;local&#34;:
        for aset in sets:
            dd.to_hdf(sets[aset], self.__fspath__(), aset, mode=mode, **kwargs)
    else:
        with tempfile.NamedTemporaryFile() as f:
            futures = self.__class__.cli.map(
                dd.to_hdf, list(sets.values()), [f.name] * len(sets), list(sets.keys()), mode=mode, **kwargs
            )
            self.__class__.cli.gather(futures)
            TransparentPath(path=f.name, fs=&#34;local&#34;, bucket=self.bucket).put(self.path)
    return</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self, data: Any, overwrite: bool = True, present: str = 'ignore', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, data: Any, overwrite: bool = True, present: str = &#34;ignore&#34;, **kwargs):

    if self.suffix != &#34;.json&#34;:
        warnings.warn(
            f&#34;path {self} does not have &#39;.json&#39; as suffix while using to_json. The path will be &#34;
            &#34;changed to a path with &#39;.json&#39; as suffix&#34;
        )
        self.change_suffix(&#34;.json&#34;)
    jsonified = json.dumps(data, cls=JSONEncoder)
    self.write_stuff(
        jsonified,
        &#34;w&#34;,
        overwrite=overwrite,
        present=present,
        **kwargs,
    )</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.to_parquet"><code class="name flex">
<span>def <span class="ident">to_parquet</span></span>(<span>self, data, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_parquet(self, data, *args, **kwargs):
    if &#34;dask&#34; in str(type(data)):
        self.to_parquet_dask(data, *args, **kwargs)
    else:
        self.to_parquet_classic(data, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.to_parquet_classic"><code class="name flex">
<span>def <span class="ident">to_parquet_classic</span></span>(<span>self, data: Union[pandas.core.frame.DataFrame, pandas.core.series.Series], overwrite: bool = True, present: str = 'ignore', columns_to_string: bool = True, to_dataframe: bool = True, **kwargs) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Warning : if data is a Dask dataframe, the output will be written in a directory. For convenience, the directory
if self.with_suffix(""). Reading is transparent and one can specify a path with .parquet suffix.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(
    self,
    data: Union[pd.DataFrame, pd.Series],
    overwrite: bool = True,
    present: str = &#34;ignore&#34;,
    columns_to_string: bool = True,
    to_dataframe: bool = True,
    **kwargs,
) -&gt; None:
    &#34;&#34;&#34;
    Warning : if data is a Dask dataframe, the output will be written in a directory. For convenience, the directory
    if self.with_suffix(&#34;&#34;). Reading is transparent and one can specify a path with .parquet suffix.
    &#34;&#34;&#34;

    if self.suffix != &#34;.parquet&#34;:
        warnings.warn(f&#34;path {self} does not have &#39;.parquet&#39; as suffix while using to_parquet. The path will be &#34;
                      f&#34;changed to a path with &#39;.parquet&#39; as suffix&#34;)
        self.change_suffix(&#34;.parquet&#34;)

    if not overwrite and self.is_file() and present != &#34;ignore&#34;:
        raise FileExistsError()

    if to_dataframe and isinstance(data, pd.Series):
        name = data.name
        data = pd.DataFrame(data=data)
        if name is not None:
            data.columns = [name]

    if columns_to_string and not isinstance(data.columns[0], str):
        # noinspection PyUnresolvedReferences
        data.columns = data.columns.astype(str)

    # noinspection PyTypeChecker
    check_kwargs(data.to_parquet, kwargs)
    if &#34;engine&#34; in kwargs:
        engine = kwargs[&#34;engine&#34;]
        del kwargs[&#34;engine&#34;]
    else:
        engine = &#34;pyarrow&#34;
    if &#34;compression&#34; in kwargs:
        compression = kwargs[&#34;compression&#34;]
        del kwargs[&#34;compression&#34;]
    else:
        compression = &#34;snappy&#34;
    if (self.fs_kind != &#34;local&#34;) and ((engine != &#34;pyarrow&#34;) or (compression != &#34;snappy&#34;)):
        with tempfile.NamedTemporaryFile(delete=True, suffix=&#34;.parquet&#34;) as f:
            data.to_parquet(f.name, engine=engine, compression=compression, **kwargs)
            TransparentPath(
                path=f.name,
                fs=&#34;local&#34;,
                notupdatecache=self.notupdatecache,
                nocheck=self.nocheck,
                when_checked=self.when_checked,
                when_updated=self.when_updated,
                update_expire=self.update_expire,
                check_expire=self.check_expire,
            ).put(self.path)
    elif self.fs_kind == &#34;local&#34;:
        data.to_parquet(str(self), engine=engine, compression=compression, **kwargs)
    else:
        data.to_parquet(self.open(&#34;wb&#34;), engine=engine, compression=compression, **kwargs)</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.to_parquet_dask"><code class="name flex">
<span>def <span class="ident">to_parquet_dask</span></span>(<span>self, data: Union[pandas.core.frame.DataFrame, pandas.core.series.Series, dask.dataframe.core.DataFrame], overwrite: bool = True, present: str = 'ignore', columns_to_string: bool = True, **kwargs) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_parquet(
    self,
    data: Union[pd.DataFrame, pd.Series, dd.DataFrame],
    overwrite: bool = True,
    present: str = &#34;ignore&#34;,
    columns_to_string: bool = True,
    **kwargs,
) -&gt; None:

    if not parquet_ok:
        raise ImportError(errormessage_hdf5)

    if self.suffix != &#34;.parquet&#34;:
        warnings.warn(f&#34;path {self} does not have &#39;.parquet&#39; as suffix while using to_parquet. The path will be &#34;
                      f&#34;changed to a path with &#39;.parquet&#39; as suffix&#34;)
        self.change_suffix(&#34;.parquet&#34;)

    compression = kwargs.get(&#34;compression&#34;, None)

    if compression is not None and compression != &#34;snappy&#34;:
        warnings.warn(&#34;TransparentPath can not write parquet files with a compression that is not snappy. You &#34;
                      f&#34;specified &#39;{compression}&#39;, it will be replaced by &#39;snappy&#39;.&#34;)

    if not self.nocheck:
        self._check_multiplicity()

    if not overwrite and self.is_file() and present != &#34;ignore&#34;:
        raise FileExistsError()

    if columns_to_string and not isinstance(data.columns[0], str):
        data.columns = data.columns.astype(str)

    if self.__class__.cli is None:
        self.__class__.cli = client.Client()
    check_kwargs(dd.to_parquet, kwargs)
    dd.to_parquet(data, self.with_suffix(&#34;&#34;).__fspath__(), engine=&#34;pyarrow&#34;, compression=&#34;snappy&#34;, **kwargs)</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.to_plotly_json"><code class="name flex">
<span>def <span class="ident">to_plotly_json</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>For compatibility with Plotly Dash</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_plotly_json(self):
    &#34;&#34;&#34;For compatibility with Plotly Dash&#34;&#34;&#34;
    return str(self)</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.touch"><code class="name flex">
<span>def <span class="ident">touch</span></span>(<span>self, present: str = 'ignore', **kwargs) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Creates the file corresponding to self if does not exist.</p>
<p>Raises FileExistsError if there already is an object that is not a file at self. Default behavior is to
create parent directories of the file if needed. This can be canceled by passing 'create_parents=False', but
only if not using GCS, since directories are not a thing on GCS.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>present</code></strong> :&ensp;<code>str</code></dt>
<dd>What to do if there is already something at self. Can be "raise" or "ignore" (Default value = "ignore")</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>The kwargs to pass to file system's touch method</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def touch(self, present: str = &#34;ignore&#34;, **kwargs) -&gt; None:
    &#34;&#34;&#34;Creates the file corresponding to self if does not exist.

    Raises FileExistsError if there already is an object that is not a file at self. Default behavior is to
    create parent directories of the file if needed. This can be canceled by passing &#39;create_parents=False&#39;, but
    only if not using GCS, since directories are not a thing on GCS.


    Parameters
    ----------
    present: str
        What to do if there is already something at self. Can be &#34;raise&#34; or &#34;ignore&#34; (Default value = &#34;ignore&#34;)

    kwargs
        The kwargs to pass to file system&#39;s touch method


    Returns
    -------
    None

    &#34;&#34;&#34;

    if present != &#34;raise&#34; and present != &#34;ignore&#34;:
        raise ValueError(f&#34;Unexpected value for argument &#39;present&#39; : {present}&#34;)

    if self.exists():
        if self.is_file() and present == &#34;raise&#34;:
            raise FileExistsError
        elif not self.is_file():
            raise FileExistsError(f&#34;There is already an object at {self} which is not a file.&#34;)
        else:
            return

    for parent in reversed(self.parents):
        p = TransparentPath(
            parent,
            fs=self.fs_kind,
            bucket=self.bucket,
            notupdatecache=self.notupdatecache,
            nocheck=self.nocheck,
            when_checked=self.when_checked,
            when_updated=self.when_updated,
            update_expire=self.update_expire,
            check_expire=self.check_expire,
        )
        if p.is_file():
            raise FileExistsError(f&#34;A parent directory can not be created because there is already a file at {p}&#34;)
        elif not p.exists():
            p.mkdir()

    self.fs.touch(self.__fspath__(), **kwargs)</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.uncache"><code class="name flex">
<span>def <span class="ident">uncache</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>remove data from cache</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uncache(self) -&gt; None:
    &#34;&#34;&#34;
    remove data from cache
    &#34;&#34;&#34;
    if self.enable_caching:
        if self.__hash__() in TransparentPath.cached_data_dict.keys():
            TransparentPath.cached_data_dict.pop(self.__hash__())
        else:
            warnings.warn(f&#34;{self} is not in cache&#34;, TPCachingWarning)</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.unlink"><code class="name flex">
<span>def <span class="ident">unlink</span></span>(<span>self, **kwargs) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Alias of rm, to match pathlib.Path method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unlink(self, **kwargs) -&gt; None:
    &#34;&#34;&#34;Alias of rm, to match pathlib.Path method&#34;&#34;&#34;
    self.rm(**kwargs)</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.update_tpcache"><code class="name flex">
<span>def <span class="ident">update_tpcache</span></span>(<span>self, data) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_tpcache(self, data) -&gt; None:
    if self.enable_caching:
        if self.caching == &#34;ram&#34;:
            if self.__hash__() in TransparentPath.cached_data_dict.keys():
                TransparentPath.cached_data_dict[self.__hash__()][&#34;data&#34;] = data
        elif self.caching == &#34;tmpfile&#34; and self.fs_kind != &#34;local&#34;:
            if self.__hash__() in TransparentPath.cached_data_dict.keys():
                TransparentPath(TransparentPath.cached_data_dict[self.__hash__()][&#34;file&#34;].name, fs=&#34;local&#34;).write(
                    data
                )</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.walk"><code class="name flex">
<span>def <span class="ident">walk</span></span>(<span>self) ‑> Iterator[Tuple[<a title="transparentpath.gcsutils.transparentpath.TransparentPath" href="#transparentpath.gcsutils.transparentpath.TransparentPath">TransparentPath</a>, List[<a title="transparentpath.gcsutils.transparentpath.TransparentPath" href="#transparentpath.gcsutils.transparentpath.TransparentPath">TransparentPath</a>], List[<a title="transparentpath.gcsutils.transparentpath.TransparentPath" href="#transparentpath.gcsutils.transparentpath.TransparentPath">TransparentPath</a>]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Like os.walk, except all outputs are TransparentPaths (so, absolute paths)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Iterator[Tuple[<a title="transparentpath.gcsutils.transparentpath.TransparentPath" href="#transparentpath.gcsutils.transparentpath.TransparentPath">TransparentPath</a>, List[<a title="transparentpath.gcsutils.transparentpath.TransparentPath" href="#transparentpath.gcsutils.transparentpath.TransparentPath">TransparentPath</a>], List[<a title="transparentpath.gcsutils.transparentpath.TransparentPath" href="#transparentpath.gcsutils.transparentpath.TransparentPath">TransparentPath</a>]]]</code></dt>
<dd>root, dirs and files, like os.walk</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def walk(self) -&gt; Iterator[Tuple[TransparentPath, List[TransparentPath], List[TransparentPath]]]:
    &#34;&#34;&#34;Like os.walk, except all outputs are TransparentPaths (so, absolute paths)

    Returns
    -------
    Iterator[Tuple[TransparentPath, List[TransparentPath], List[TransparentPath]]]
        root, dirs and files, like os.walk
    &#34;&#34;&#34;

    if self.when_checked[&#34;used&#34;] and not self.nocheck:
        self._check_multiplicity()
    # No need to update cache for walk

    outputs = self.fs.walk(self.__fspath__())
    for output in outputs:
        root = TransparentPath(
            output[0],
            fs=self.fs_kind,
            bucket=self.bucket,
            notupdatecache=self.notupdatecache,
            nocheck=self.nocheck,
            when_checked=self.when_checked,
            when_updated=self.when_updated,
            update_expire=self.update_expire,
            check_expire=self.check_expire,
        )
        dirs = [root / p for p in output[1]]
        files = [root / p for p in output[2]]
        yield root, dirs, files</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.with_suffix"><code class="name flex">
<span>def <span class="ident">with_suffix</span></span>(<span>self, suffix: str) ‑> <a title="transparentpath.gcsutils.transparentpath.TransparentPath" href="#transparentpath.gcsutils.transparentpath.TransparentPath">TransparentPath</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns a new TransparentPath object with a changed suffix
Uses the with_suffix method of pathlib.Path</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>suffix</code></strong> :&ensp;<code>str</code></dt>
<dd>suffix to use, with the dot ('.pdf', '.py', etc ..). Can also use '' to remove the suffix.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath" href="#transparentpath.gcsutils.transparentpath.TransparentPath">TransparentPath</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_suffix(self, suffix: str) -&gt; TransparentPath:
    &#34;&#34;&#34;Returns a new TransparentPath object with a changed suffix
    Uses the with_suffix method of pathlib.Path


    Parameters
    -----------
    suffix: str
        suffix to use, with the dot (&#39;.pdf&#39;, &#39;.py&#39;, etc ..). Can also use &#39;&#39; to remove the suffix.

    Returns
    --------
    TransparentPath

    &#34;&#34;&#34;
    if not suffix.startswith(&#34;.&#34;) and not suffix == &#34;&#34;:
        suffix = f&#34;.{suffix}&#34;
    return TransparentPath(
        self.__path.with_suffix(suffix),
        fs=self.fs_kind,
        bucket=self.bucket,
        notupdatecache=self.notupdatecache,
        nocheck=self.nocheck,
        when_checked=self.when_checked,
        when_updated=self.when_updated,
        update_expire=self.update_expire,
        check_expire=self.check_expire,
    )</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, data: Any, *args, set_name: str = 'data', use_pandas: bool = False, overwrite: bool = True, present: str = 'ignore', make_parents: bool = False, **kwargs) ‑> Union[None, pd.HDFStore, h5py.File]</span>
</code></dt>
<dd>
<div class="desc"><p>Method used to write the content of the file located at self
Calls a specific method to write data based on the suffix of self.path:
1: .csv : will use pandas's to_csv
2: .parquet : will use pandas's to_parquet with pyarrow engine
3: .hdf5 or .h5 : will use h5py.File. Since it does not support remote file systems, the file will be
created localy in a tmp filen written to, then uploaded and removed localy.
4: .json : will use jsonencoder.JSONEncoder class. Works with DataFrames and np.ndarrays too.
5: .xlsx : will use pandas's to_excel
5: any other suffix : uses self.open to write to an IO Buffer
Parameters</p>
<hr>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>Any</code></dt>
<dd>The data to write</dd>
<dt><strong><code>set_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the dataset to write. Only relevant if using HDF5 (Default value = 'data')</dd>
<dt><strong><code>use_pandas</code></strong> :&ensp;<code>bool</code></dt>
<dd>Must pass it as True if hdf file must be written using HDFStore and not h5py.File</dd>
<dt><strong><code>overwrite</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, any existing file will be overwritten. Only relevant for csv, hdf5 and parquet files,
since others use the 'open' method, which args already specify what to do (Default value = True).</dd>
<dt><strong><code>present</code></strong> :&ensp;<code>str</code></dt>
<dd>Indicates what to do if overwrite is False and file is present. Here too, only relevant for csv,
hsf5 and parquet files.</dd>
<dt><strong><code>make_parents</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True and if the parent arborescence does not exist, it is created. (Default value = False)</dd>
</dl>
<p>args:
any args to pass to the underlying writting method
kwargs:
any kwargs to pass to the underlying reading method
Returns</p>
<hr>
<dl>
<dt><code>Union[None, pd.HDFStore, h5py.File]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(
    self,
    data: Any,
    *args,
    set_name: str = &#34;data&#34;,
    use_pandas: bool = False,
    overwrite: bool = True,
    present: str = &#34;ignore&#34;,
    make_parents: bool = False,
    **kwargs,
) -&gt; Union[None, &#34;pd.HDFStore&#34;, &#34;h5py.File&#34;]:
    &#34;&#34;&#34;Method used to write the content of the file located at self
    Calls a specific method to write data based on the suffix of self.path:
        1: .csv : will use pandas&#39;s to_csv
        2: .parquet : will use pandas&#39;s to_parquet with pyarrow engine
        3: .hdf5 or .h5 : will use h5py.File. Since it does not support remote file systems, the file will be
        created localy in a tmp filen written to, then uploaded and removed localy.
        4: .json : will use jsonencoder.JSONEncoder class. Works with DataFrames and np.ndarrays too.
        5: .xlsx : will use pandas&#39;s to_excel
        5: any other suffix : uses self.open to write to an IO Buffer
    Parameters
    ----------
    data: Any
        The data to write
    set_name: str
        Name of the dataset to write. Only relevant if using HDF5 (Default value = &#39;data&#39;)
    use_pandas: bool
        Must pass it as True if hdf file must be written using HDFStore and not h5py.File
    overwrite: bool
        If True, any existing file will be overwritten. Only relevant for csv, hdf5 and parquet files,
        since others use the &#39;open&#39; method, which args already specify what to do (Default value = True).
    present: str
        Indicates what to do if overwrite is False and file is present. Here too, only relevant for csv,
        hsf5 and parquet files.
    make_parents: bool
        If True and if the parent arborescence does not exist, it is created. (Default value = False)
    args:
        any args to pass to the underlying writting method
    kwargs:
        any kwargs to pass to the underlying reading method
    Returns
    -------
    Union[None, pd.HDFStore, h5py.File]
    &#34;&#34;&#34;
    # Update cache and/or check multiplicity are called inside each specific reading method

    if make_parents and not self.parent.is_dir():
        self.parent.mkdir()

    if self.suffix != &#34;.hdf5&#34; and self.suffix != &#34;.h5&#34; and data is None:
        data = args[0]
        args = args[1:]

    if self.suffix == &#34;.csv&#34;:
        ret = self.to_csv(
            data=data,
            overwrite=overwrite,
            present=present,
            **kwargs,
        )
        if ret is not None:
            # To skip the assert at the end of the function. Indeed if something is returned it means we used
            # Dask, which will have written files with a different name than self, so the assert would fail.
            return
    elif self.suffix == &#34;.parquet&#34;:
        self.to_parquet(
            data=data,
            overwrite=overwrite,
            present=present,
            **kwargs,
        )
        if &#34;dask&#34; in str(type(data)):
            # noinspection PyUnresolvedReferences
            assert self.with_suffix(&#34;&#34;).is_dir(exist=True)
            return
    elif self.suffix == &#34;.hdf5&#34; or self.suffix == &#34;.h5&#34;:
        ret = self.to_hdf5(
            data=data,
            set_name=set_name,
            use_pandas=use_pandas,
            **kwargs,
        )
        if ret is not None:
            # will not cache the changes for they will happen outside TransparentPath
            return ret
    elif self.suffix == &#34;.json&#34;:
        self.to_json(
            data=data,
            overwrite=overwrite,
            present=present,
            **kwargs,
        )
    elif self.suffix == &#34;.txt&#34;:
        self.write_stuff(
            *args,
            data=data,
            overwrite=overwrite,
            present=present,
            **kwargs,
        )
    elif self.suffix in [&#34;.xlsx&#34;, &#34;.xls&#34;, &#34;.xlsm&#34;]:
        self.to_excel(
            data=data,
            overwrite=overwrite,
            present=present,
            **kwargs,
        )
    else:
        self.write_bytes(
            *args,
            data=data,
            overwrite=overwrite,
            present=present,
            **kwargs,
        )
    self.update_tpcache(data)
    assert self.is_file()</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.write_bytes"><code class="name flex">
<span>def <span class="ident">write_bytes</span></span>(<span>self, data: Any, *args, overwrite: bool = True, present: str = 'ignore', **kwargs) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_bytes(self, data: Any, *args, overwrite: bool = True, present: str = &#34;ignore&#34;, **kwargs,) -&gt; None:

    args = list(args)
    if len(args) == 0:
        args = (&#34;wb&#34;,)
    if &#34;b&#34; not in args[0]:
        args[0] += &#34;b&#34;

    self.write_stuff(data, *tuple(args), overwrite=overwrite, present=present, **kwargs)</code></pre>
</details>
</dd>
<dt id="transparentpath.gcsutils.transparentpath.TransparentPath.write_stuff"><code class="name flex">
<span>def <span class="ident">write_stuff</span></span>(<span>self, data: Any, *args, overwrite: bool = True, present: str = 'ignore', **kwargs) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_stuff(self, data: Any, *args, overwrite: bool = True, present: str = &#34;ignore&#34;, **kwargs) -&gt; None:

    if not overwrite and self.is_file() and present != &#34;ignore&#34;:
        raise FileExistsError()

    args = list(args)
    if len(args) == 0:
        args = (&#34;w&#34;,)

    with self.open(*args, **kwargs) as f:
        f.write(data)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="transparentpath.gcsutils" href="index.html">transparentpath.gcsutils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="transparentpath.gcsutils.transparentpath.check_bucket" href="#transparentpath.gcsutils.transparentpath.check_bucket">check_bucket</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.check_kwargs" href="#transparentpath.gcsutils.transparentpath.check_kwargs">check_kwargs</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.collapse_ddots" href="#transparentpath.gcsutils.transparentpath.collapse_ddots">collapse_ddots</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.errorfunction" href="#transparentpath.gcsutils.transparentpath.errorfunction">errorfunction</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.errormessage" href="#transparentpath.gcsutils.transparentpath.errormessage">errormessage</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.extract_fs_name" href="#transparentpath.gcsutils.transparentpath.extract_fs_name">extract_fs_name</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.get_buckets" href="#transparentpath.gcsutils.transparentpath.get_buckets">get_buckets</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.get_fs" href="#transparentpath.gcsutils.transparentpath.get_fs">get_fs</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.get_index_and_date_from_kwargs" href="#transparentpath.gcsutils.transparentpath.get_index_and_date_from_kwargs">get_index_and_date_from_kwargs</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.myisinstance" href="#transparentpath.gcsutils.transparentpath.myisinstance">myisinstance</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.mysmallisinstance" href="#transparentpath.gcsutils.transparentpath.mysmallisinstance">mysmallisinstance</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.treat_remote_prefix" href="#transparentpath.gcsutils.transparentpath.treat_remote_prefix">treat_remote_prefix</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="transparentpath.gcsutils.transparentpath.TPCachingWarning" href="#transparentpath.gcsutils.transparentpath.TPCachingWarning">TPCachingWarning</a></code></h4>
</li>
<li>
<h4><code><a title="transparentpath.gcsutils.transparentpath.TPMultipleExistenceError" href="#transparentpath.gcsutils.transparentpath.TPMultipleExistenceError">TPMultipleExistenceError</a></code></h4>
</li>
<li>
<h4><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath" href="#transparentpath.gcsutils.transparentpath.TransparentPath">TransparentPath</a></code></h4>
<ul class="">
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.LOCAL_SEP" href="#transparentpath.gcsutils.transparentpath.TransparentPath.LOCAL_SEP">LOCAL_SEP</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.absolute" href="#transparentpath.gcsutils.transparentpath.TransparentPath.absolute">absolute</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.append" href="#transparentpath.gcsutils.transparentpath.TransparentPath.append">append</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.bucket" href="#transparentpath.gcsutils.transparentpath.TransparentPath.bucket">bucket</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.buckets" href="#transparentpath.gcsutils.transparentpath.TransparentPath.buckets">buckets</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.buckets_in_project" href="#transparentpath.gcsutils.transparentpath.TransparentPath.buckets_in_project">buckets_in_project</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.cached_data_dict" href="#transparentpath.gcsutils.transparentpath.TransparentPath.cached_data_dict">cached_data_dict</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.caching" href="#transparentpath.gcsutils.transparentpath.TransparentPath.caching">caching</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.caching_max_memory" href="#transparentpath.gcsutils.transparentpath.TransparentPath.caching_max_memory">caching_max_memory</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.caching_ram" href="#transparentpath.gcsutils.transparentpath.TransparentPath.caching_ram">caching_ram</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.caching_saver" href="#transparentpath.gcsutils.transparentpath.TransparentPath.caching_saver">caching_saver</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.caching_tmpfile" href="#transparentpath.gcsutils.transparentpath.TransparentPath.caching_tmpfile">caching_tmpfile</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.cd" href="#transparentpath.gcsutils.transparentpath.TransparentPath.cd">cd</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.change_suffix" href="#transparentpath.gcsutils.transparentpath.TransparentPath.change_suffix">change_suffix</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.cli" href="#transparentpath.gcsutils.transparentpath.TransparentPath.cli">cli</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.cp" href="#transparentpath.gcsutils.transparentpath.TransparentPath.cp">cp</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.cwd" href="#transparentpath.gcsutils.transparentpath.TransparentPath.cwd">cwd</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.download" href="#transparentpath.gcsutils.transparentpath.TransparentPath.download">download</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.exist" href="#transparentpath.gcsutils.transparentpath.TransparentPath.exist">exist</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.exists" href="#transparentpath.gcsutils.transparentpath.TransparentPath.exists">exists</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.fs_kind" href="#transparentpath.gcsutils.transparentpath.TransparentPath.fs_kind">fs_kind</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.fss" href="#transparentpath.gcsutils.transparentpath.TransparentPath.fss">fss</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.get" href="#transparentpath.gcsutils.transparentpath.TransparentPath.get">get</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.get_absolute" href="#transparentpath.gcsutils.transparentpath.TransparentPath.get_absolute">get_absolute</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.get_state" href="#transparentpath.gcsutils.transparentpath.TransparentPath.get_state">get_state</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.glob" href="#transparentpath.gcsutils.transparentpath.TransparentPath.glob">glob</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.is_dir" href="#transparentpath.gcsutils.transparentpath.TransparentPath.is_dir">is_dir</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.is_file" href="#transparentpath.gcsutils.transparentpath.TransparentPath.is_file">is_file</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.isdir" href="#transparentpath.gcsutils.transparentpath.TransparentPath.isdir">isdir</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.isfile" href="#transparentpath.gcsutils.transparentpath.TransparentPath.isfile">isfile</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.ls" href="#transparentpath.gcsutils.transparentpath.TransparentPath.ls">ls</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.method_path_concat" href="#transparentpath.gcsutils.transparentpath.TransparentPath.method_path_concat">method_path_concat</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.method_without_self_path" href="#transparentpath.gcsutils.transparentpath.TransparentPath.method_without_self_path">method_without_self_path</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.mkbucket" href="#transparentpath.gcsutils.transparentpath.TransparentPath.mkbucket">mkbucket</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.mkdir" href="#transparentpath.gcsutils.transparentpath.TransparentPath.mkdir">mkdir</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.mv" href="#transparentpath.gcsutils.transparentpath.TransparentPath.mv">mv</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.nas_dir" href="#transparentpath.gcsutils.transparentpath.TransparentPath.nas_dir">nas_dir</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.path" href="#transparentpath.gcsutils.transparentpath.TransparentPath.path">path</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.put" href="#transparentpath.gcsutils.transparentpath.TransparentPath.put">put</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.read" href="#transparentpath.gcsutils.transparentpath.TransparentPath.read">read</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.read_csv" href="#transparentpath.gcsutils.transparentpath.TransparentPath.read_csv">read_csv</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.read_csv_classic" href="#transparentpath.gcsutils.transparentpath.TransparentPath.read_csv_classic">read_csv_classic</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.read_csv_dask" href="#transparentpath.gcsutils.transparentpath.TransparentPath.read_csv_dask">read_csv_dask</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.read_excel" href="#transparentpath.gcsutils.transparentpath.TransparentPath.read_excel">read_excel</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.read_excel_classic" href="#transparentpath.gcsutils.transparentpath.TransparentPath.read_excel_classic">read_excel_classic</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.read_excel_dask" href="#transparentpath.gcsutils.transparentpath.TransparentPath.read_excel_dask">read_excel_dask</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.read_hdf5" href="#transparentpath.gcsutils.transparentpath.TransparentPath.read_hdf5">read_hdf5</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.read_hdf5_classic" href="#transparentpath.gcsutils.transparentpath.TransparentPath.read_hdf5_classic">read_hdf5_classic</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.read_hdf5_dask" href="#transparentpath.gcsutils.transparentpath.TransparentPath.read_hdf5_dask">read_hdf5_dask</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.read_json" href="#transparentpath.gcsutils.transparentpath.TransparentPath.read_json">read_json</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.read_parquet" href="#transparentpath.gcsutils.transparentpath.TransparentPath.read_parquet">read_parquet</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.read_parquet_classic" href="#transparentpath.gcsutils.transparentpath.TransparentPath.read_parquet_classic">read_parquet_classic</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.read_parquet_dask" href="#transparentpath.gcsutils.transparentpath.TransparentPath.read_parquet_dask">read_parquet_dask</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.read_text" href="#transparentpath.gcsutils.transparentpath.TransparentPath.read_text">read_text</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.refresh_cache" href="#transparentpath.gcsutils.transparentpath.TransparentPath.refresh_cache">refresh_cache</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.reinit" href="#transparentpath.gcsutils.transparentpath.TransparentPath.reinit">reinit</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.remote_prefix" href="#transparentpath.gcsutils.transparentpath.TransparentPath.remote_prefix">remote_prefix</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.rm" href="#transparentpath.gcsutils.transparentpath.TransparentPath.rm">rm</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.rmbucket" href="#transparentpath.gcsutils.transparentpath.TransparentPath.rmbucket">rmbucket</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.rmdir" href="#transparentpath.gcsutils.transparentpath.TransparentPath.rmdir">rmdir</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.set_global_fs" href="#transparentpath.gcsutils.transparentpath.TransparentPath.set_global_fs">set_global_fs</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.show_state" href="#transparentpath.gcsutils.transparentpath.TransparentPath.show_state">show_state</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.stat" href="#transparentpath.gcsutils.transparentpath.TransparentPath.stat">stat</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.to_csv" href="#transparentpath.gcsutils.transparentpath.TransparentPath.to_csv">to_csv</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.to_csv_classic" href="#transparentpath.gcsutils.transparentpath.TransparentPath.to_csv_classic">to_csv_classic</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.to_csv_dask" href="#transparentpath.gcsutils.transparentpath.TransparentPath.to_csv_dask">to_csv_dask</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.to_excel" href="#transparentpath.gcsutils.transparentpath.TransparentPath.to_excel">to_excel</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.to_excel_classic" href="#transparentpath.gcsutils.transparentpath.TransparentPath.to_excel_classic">to_excel_classic</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.to_excel_dask" href="#transparentpath.gcsutils.transparentpath.TransparentPath.to_excel_dask">to_excel_dask</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.to_hdf5" href="#transparentpath.gcsutils.transparentpath.TransparentPath.to_hdf5">to_hdf5</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.to_hdf5_classic" href="#transparentpath.gcsutils.transparentpath.TransparentPath.to_hdf5_classic">to_hdf5_classic</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.to_hdf5_dask" href="#transparentpath.gcsutils.transparentpath.TransparentPath.to_hdf5_dask">to_hdf5_dask</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.to_json" href="#transparentpath.gcsutils.transparentpath.TransparentPath.to_json">to_json</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.to_parquet" href="#transparentpath.gcsutils.transparentpath.TransparentPath.to_parquet">to_parquet</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.to_parquet_classic" href="#transparentpath.gcsutils.transparentpath.TransparentPath.to_parquet_classic">to_parquet_classic</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.to_parquet_dask" href="#transparentpath.gcsutils.transparentpath.TransparentPath.to_parquet_dask">to_parquet_dask</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.to_plotly_json" href="#transparentpath.gcsutils.transparentpath.TransparentPath.to_plotly_json">to_plotly_json</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.tokens" href="#transparentpath.gcsutils.transparentpath.TransparentPath.tokens">tokens</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.touch" href="#transparentpath.gcsutils.transparentpath.TransparentPath.touch">touch</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.translations" href="#transparentpath.gcsutils.transparentpath.TransparentPath.translations">translations</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.uncache" href="#transparentpath.gcsutils.transparentpath.TransparentPath.uncache">uncache</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.unlink" href="#transparentpath.gcsutils.transparentpath.TransparentPath.unlink">unlink</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.unset" href="#transparentpath.gcsutils.transparentpath.TransparentPath.unset">unset</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.update_tpcache" href="#transparentpath.gcsutils.transparentpath.TransparentPath.update_tpcache">update_tpcache</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.url" href="#transparentpath.gcsutils.transparentpath.TransparentPath.url">url</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.used_memory" href="#transparentpath.gcsutils.transparentpath.TransparentPath.used_memory">used_memory</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.walk" href="#transparentpath.gcsutils.transparentpath.TransparentPath.walk">walk</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.with_suffix" href="#transparentpath.gcsutils.transparentpath.TransparentPath.with_suffix">with_suffix</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.write" href="#transparentpath.gcsutils.transparentpath.TransparentPath.write">write</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.write_bytes" href="#transparentpath.gcsutils.transparentpath.TransparentPath.write_bytes">write_bytes</a></code></li>
<li><code><a title="transparentpath.gcsutils.transparentpath.TransparentPath.write_stuff" href="#transparentpath.gcsutils.transparentpath.TransparentPath.write_stuff">write_stuff</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>